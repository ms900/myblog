/*
Navicat MySQL Data Transfer

Source Server         : localhost_3306
Source Server Version : 50724
Source Host           : localhost:3306
Source Database       : myblog

Target Server Type    : MYSQL
Target Server Version : 50724
File Encoding         : 65001

Date: 2023-02-27 20:04:32
*/

SET FOREIGN_KEY_CHECKS=0;

-- ----------------------------
-- Table structure for tb_admin_user
-- ----------------------------
DROP TABLE IF EXISTS `tb_admin_user`;
CREATE TABLE `tb_admin_user` (
  `admin_user_id` int(11) NOT NULL AUTO_INCREMENT COMMENT '管理员id',
  `login_user_name` varchar(50) NOT NULL COMMENT '管理员登陆名称',
  `login_password` varchar(50) NOT NULL COMMENT '管理员登陆密码',
  `nick_name` varchar(50) NOT NULL COMMENT '管理员显示昵称',
  `locked` tinyint(4) DEFAULT '0' COMMENT '是否锁定 0未锁定 1已锁定无法登陆',
  PRIMARY KEY (`admin_user_id`)
) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of tb_admin_user
-- ----------------------------
INSERT INTO `tb_admin_user` VALUES ('1', 'mashuan', 'a75841e64f6346b3269434fe4bfa24c5', 'mashuan', '0');

-- ----------------------------
-- Table structure for tb_blog
-- ----------------------------
DROP TABLE IF EXISTS `tb_blog`;
CREATE TABLE `tb_blog` (
  `blog_id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT '博客表主键id',
  `blog_title` varchar(200) NOT NULL COMMENT '博客标题',
  `blog_summary` varchar(500) NOT NULL COMMENT '博客摘要',
  `blog_content` mediumtext NOT NULL COMMENT '博客内容',
  `blog_category_id` int(11) NOT NULL COMMENT '博客分类id',
  `blog_category_name` varchar(50) NOT NULL COMMENT '博客分类(冗余字段)',
  `blog_tags` varchar(200) NOT NULL COMMENT '博客标签',
  `blog_status` tinyint(4) NOT NULL DEFAULT '0' COMMENT '0-草稿 1-发布',
  `blog_views` bigint(20) NOT NULL DEFAULT '0' COMMENT '阅读量',
  `enable_comment` tinyint(4) NOT NULL DEFAULT '0' COMMENT '0-允许评论 1-不允许评论',
  `is_deleted` tinyint(4) NOT NULL DEFAULT '0' COMMENT '是否删除 0=否 1=是',
  `create_time` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '添加时间',
  `update_time` datetime DEFAULT CURRENT_TIMESTAMP COMMENT '修改时间',
  PRIMARY KEY (`blog_id`)
) ENGINE=InnoDB AUTO_INCREMENT=16 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of tb_blog
-- ----------------------------
INSERT INTO `tb_blog` VALUES ('1', '批量重命名音乐文件', '批量重命名音乐文件  从酷狗音乐下载音乐时，发现下载的音乐的文件名都是以歌手开头，看着很难受，而且在酷狗的下载设置里没有下载的文件名设置。 简而言之这个小程序就是将文件名为歌手 - 音乐名.后缀的音乐文件批量修改为音乐名-歌手.后缀的样式  先看下效果', '# 批量重命名音乐文件\n\n从酷狗音乐下载音乐时，发现下载的音乐的文件名都是以歌手开头，看着很难受，而且在酷狗的下载设置里没有下载的文件名设置。\n\n简而言之这个小程序就是将文件名为`歌手 - 音乐名.后缀`的音乐文件批量修改为`音乐名-歌手.后缀`的样式\n\n先看下效果\n\n![实现效果](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL2V0ZXJuaWRhZDMzL3BpY2JlZEBtYXN0ZXIvaW1nL1JlbmFtZU11c2ljLmdpZg)\n\n### 思路\n\n1. 获取音乐文件\n2. 利用正则改名\n3. 文件改名\n4. 简单地设计一下界面\n\n### 详细步骤\n\n<font color=#00f>1. 先设计核心代码，重命名</font>\n\n   例如`周杰伦 - 青花瓷.flac`文件就需要把他改为`青花瓷-周杰伦.flac`（修改之前的文件名是包含空格的）\n\n```java\npublic static String getNewName(String oldName) {\n    String newName;\n    //去掉字符串的所有空格\n    newName = oldName.replaceAll(\" \", \"\");\n    //分离歌手，歌名，文件后缀\n    String[] results = newName.split(\"-|\\\\.\");\n    //连接新的字符串\n    if (results.length == 3) {\n        newName = results[1] + \"-\" + results[0] + \".\" + results[2];\n    }\n    return newName;\n}\n```\n\n本方法传入的形参为要修改的文件名，返回修改后的文件名\n\n<font color=#00f>2. 设计重命名单个文件的方法</font>\n\n```java\npublic static void rename(File file, String fileName) {\n    //文件类型不是目录\n    if (!file.isDirectory()) {\n        File newFile = new File(file.getParent(), fileName);\n        file.renameTo(newFile);\n        System.out.println(\"修改完成：\" + newFile.getName());\n    }\n}\n```\n\n传入的形参为文件和修改后的文件名\n\n<font color=#00f>3. 重命名音乐目录下的文件</font>\n\n```java\npublic static void renameMusicDirectory(File directoryFile) {\n    if (directoryFile.isDirectory()) {\n        File[] results = directoryFile.listFiles();\n        for (int i = 0; i < results.length; i++) {\n            if (results[i].isFile()) {\n                String newName = getNewName(results[i].getName());\n                System.out.println(\"修改前的名称：\" + results[i].getName());\n                rename(results[i], newName);\n            }\n        }\n    }\n}\n```\n\n参数只需传入文件目录即可，然后循环调用单个文件重命名的方法即可\n\n **源码已上传至本人的[GitHub仓库](https://github.com/eternidad33/MyTools-mini/tree/master/RenameMusic) ，欢迎访问**。\n \n> 也可以花费5个积分通过[CSDN](https://download.csdn.net/download/qq_42907802/12332919)下载，支持我一下!', '25', '开发', 'java', '1', '713', '0', '0', '2020-04-17 10:08:03', '2020-04-17 10:08:03');
INSERT INTO `tb_blog` VALUES ('2', '将仓库的文件转换成 Markdown 格式的链接', '在GitHub的README文件中为自己的文章生成目录，由于一行一行的重复类似的代码，一个一个的打字比较麻烦，所以就想到设计一个程序转换Markdown格式。  先看效果:', '在GitHub的README文件中为自己的文章生成目录，由于一行一行的重复类似的代码，一个一个的打字比较麻烦，所以就想到设计一个程序转换Markdown格式。\n\n先看效果:\n\n![toMDLink](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL2V0ZXJuaWRhZDMzL3BpY2JlZEBtYXN0ZXIvaW1nL3RvTURMaW5rLmdpZg)\n\n\n### 思路\n\n1. 获取文件目录\n2. 将其中的文件名转换成`[文件名](文件路径)`格式\n3. 输出运行结果\n\n### 步骤\n\n<font color=#00f size=5>1. 定义将文件转换成Markdown链接格式的方法</font>\n\n例如articles目录下的文件`Java进阶-数组.ipynb`文件转换为Markdown格式的链接为`[Java进阶-数组](/articles/Java进阶-数组.ipynb)`\n\n```java\npublic static String toMDLink(File file) {\n    String fileName = file.getName();\n    String fileParentName = file.getParentFile().getName();\n    return \"- [\" + fileName.substring(0, fileName.lastIndexOf(\'.\')) + \"](/\" + fileParentName + \'/\' + fileName + \")\";\n}\n```\n\n可以将链接拆成`[ `，`去后缀的文件名`，`](/`，`父目录名`，`/`，``文件名`，`)`\n\n只需获取到`去后缀的文件名`，`父目录名`和`文件名`即可\n\n文件名：`file.getName()`\n\n父目录名：`file.getParentFile().getName()`\n\n去后缀的文件名：`fileName.substring(0, fileName.lastIndexOf(\'.\'))`\n\n<font color=#00f size=5>2. 将文件夹中的所有文件转换成Markdown链接</font>\n\n```java\npublic static StringBuffer getStringBuffer(String str) {\n    StringBuffer sb = new StringBuffer();\n    File file = new File(str);\n    if (file.isDirectory()) {\n        File[] results = file.listFiles();\n        for (int i = 0; i < results.length; i++) {\n            if (results[i].isFile()) {\n                sb.append(toMDLink(results[i])).append(\'\\n\');\n            }\n        }\n    }\n    return sb;\n}\n```\n\n参数为目录的路径，遍历该目录下的所有文件，并把转换后的字符串保存在`StringBuffer`对象中，每个结果用`\\n`换行以便于输出。\n\n**源码已上传至本人的[GitHub仓库](https://github.com/eternidad33/MyTools-mini/tree/master/FileNameToMDLink)，欢迎访问**', '24', '日常随笔', 'java,markdown', '1', '143', '0', '0', '2020-04-17 19:56:37', '2020-04-17 19:56:37');
INSERT INTO `tb_blog` VALUES ('3', '简易的图书管理系统', '简易的图书管理系统 项目简介  推荐视频：JAVA+MySql 图书管理系统，技术:Swing+jdbc+mysql 用到的知识：Java，MySQL 工具：IDEA 源码已上传至码云', '# 简易的图书管理系统\n\n## 项目简介\n\n推荐视频：[JAVA+MySql 图书管理系统，技术:Swing+jdbc+mysql](https://www.bilibili.com/video/BV1it41157ph?p=1)\n\n用到的知识：Java，MySQL\n\n工具：IDEA\n\n源码已上传至[码云](https://gitee.com/eternidad33/BookManager)\n\n[点击查看预览效果](https://gitee.com/eternidad33/BookManager)\n\n\n## 项目整体架构\n\n源码目录如下：\n\n```powershell\nPS E:\\IdeaProjects\\BookManager\\src> tree /f\n卷 软件 的文件夹 PATH 列表\n卷序列号为 54DD-69A2\nE:.\n├─dao\n│      BookDao.java\n│      BookTypeDao.java\n│      UserDao.java\n│\n├─entity\n│      Book.java\n│      Booktype.java\n│      User.java\n│\n├─images\n│      book.png\n│      susu.jpg\n│\n├─META-INF\n│      MANIFEST.MF\n│\n├─util\n│      DbUtil.java\n│      StringUtil.java\n│\n└─view\n        About.java\n        About.jfd\n        BookAddFrm.java\n        BookAddFrm.jfd\n        BookTypeAddFrm.java\n        BookTypeAddFrm.jfd\n        BookTypeManagerFrm.java\n        BookTypeManagerFrm.jfd\n        Login.form\n        Login.java\n        MainFrm.java\n        MainFrm.jfd\n```\n\n由此可见，本项目也是采用的MVC架构，`dao包`用于操作数据库，`entity包`包含本项目的实体类，`images包`是本项目用到的图片，`META-INF包`是生成Jar包时产生的文件夹，`util包`包含本项目用到的工具类，`view包`是本项目的视图层，用于设计窗口显示。\n\n项目中各类的依赖关系如下图\n\n![BookManager](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9naXRlZS5jb20vZXRlcm5pZGFkMzMvcGljYmVkL3Jhdy9tYXN0ZXIvaW1nL0Jvb2tNYW5hZ2VyLnBuZw?x-oss-process=image/format,png)\n\n## 具体实现\n\n### util包\n\n本项目的工具包，包含两个工具类\n\n`DbUtil.java`主要是设计了数据库的驱动，地址，用户名及密码，和控制数据库的连接与断开\n\n`StringUtil.java`只是用于判断字符串是否为空，只有空格也算为空\n\n---\n\n### entity包\n\n此包包含了数据库表的实体对象，可以自己写，也可以通过idea的`EasyCode`插件进行代码生成，但是后边要用到的必要的构造方法要自己写。\n\n大多数情况下都是简单类包含Getter和Setter方法，如下是`EasyCode`插件生成的代码\n\n```java\npublic class Booktype implements Serializable {\n    private static final long serialVersionUID = -43707012852599825L;\n\n    private Integer id;\n\n    private String booktypename;\n\n    @Override\n    public String toString() {\n        return this.booktypename;\n    }\n\n    private String booktypedesc;\n\n    public Booktype(String booktypename, String booktypedesc) {\n        this.booktypename = booktypename;\n        this.booktypedesc = booktypedesc;\n    }\n\n    public Booktype() {\n        super();\n    }\n\n    public Booktype(Integer id, String booktypename, String booktypedesc) {\n        this(booktypename, booktypedesc);\n        this.id = id;\n    }\n\n    public Integer getId() {\n        return id;\n    }\n\n    public void setId(Integer id) {\n        this.id = id;\n    }\n\n    public String getBooktypename() {\n        return booktypename;\n    }\n\n    public void setBooktypename(String booktypename) {\n        this.booktypename = booktypename;\n    }\n\n    public String getBooktypedesc() {\n        return booktypedesc;\n    }\n\n    public void setBooktypedesc(String booktypedesc) {\n        this.booktypedesc = booktypedesc;\n    }\n\n}\n```\n\n---\n\n### dao包\n\n进行数据库的访问\n\n类中的方法定义形式基本为`public 返回类型 方法名(Connection conn, 实体类 对象名) throws SQLException`\n\n例如用户登录的方法如下：\n\n```java\npublic User login(Connection connection, User user) throws SQLException {\n    User resultUser = null;\n    String sql = \"select * from table_user where userName=? and password=?\";\n    PreparedStatement psmt = connection.prepareStatement(sql);\n    psmt.setString(1, user.getUserName());\n    psmt.setString(2, user.getPassword());\n    ResultSet resultSet = psmt.executeQuery();\n    if (resultSet.next()) {\n        resultUser = new User();\n        resultUser.setId(resultSet.getInt(\"id\"));\n        resultUser.setUserName(resultSet.getString(\"userName\"));\n        resultUser.setPassword(resultSet.getString(\"password\"));\n    }\n    return resultUser;\n}\n```\n\n步骤总结：\n\n1. 其中SQL语句中的要查找的值要用`?`代替，方便后面设置\n\n   `String sql = \"select * from table_user where userName=? and password=?\";`\n\n2. 然后创建SQL语句的游标对象\n\n   `psmt`，`PreparedStatement psmt = connection.prepareStatement(sql);`\n\n3. 设置SQL语句中的变量值，**第几个`?`为几，索引就是几，没有0**\n\n   `psmt.setString(1, user.getUserName());`\n\n4. 执行查询语句，并返回`ResultSet`对象用于保存查询结果\n\n   `ResultSet resultSet = psmt.executeQuery();`\n\n5. 然后根据需求进行其他操作\n\n---\n\n`BookDao`类的设计如下，`dao`包下的其他类类似\n\n![](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL2V0ZXJuaWRhZDMzL3BpY2JlZEBtYXN0ZXIvaW1nL2Jvb2tEYW8ucG5n?x-oss-process=image/format,png)\n\n\n<font color=#0f0>添加图书</font>\n\n```java\npublic static int add(Connection connection, Book book) throws SQLException {\n    String sql = \"insert into book values(null,?,?,?,?,?,?)\";\n    PreparedStatement psmt = connection.prepareStatement(sql);\n    psmt.setString(1, book.getBookname());\n    psmt.setString(2, book.getAuthor());\n    psmt.setString(3, book.getSex());\n    psmt.setInt(4, book.getBooktypeid());\n    psmt.setString(5, book.getBookdesc());\n    psmt.setFloat(6, book.getPrice());\n    return psmt.executeUpdate();\n}\n```\n\n添加成功返回1，添加失败返回0\n\n---\n\n<font color=#f00>删除图书</font>\n\n```java\npublic static int delete(Connection conn, String id) throws SQLException {\n    String sql = \"delete from book where id=?\";\n    PreparedStatement psmt = conn.prepareStatement(sql);\n    psmt.setString(1, id);\n    return psmt.executeUpdate();\n}\n```\n\n删除成功返回1，删除失败返回0\n\n---\n\n<font color=#fc0>修改图书</font>\n\n```java\npublic static int update(Connection conn, Book book) throws SQLException {\n    String sql = \"update book set bookName=?,author=?,sex=?,price=?,bookTypeid=?,bookDesc=? where id=?\";\n    PreparedStatement psmt = conn.prepareStatement(sql);\n    psmt.setString(1, book.getBookname());\n    psmt.setString(2, book.getAuthor());\n    psmt.setString(3, book.getSex());\n    psmt.setFloat(4, book.getPrice());\n    psmt.setInt(5, book.getBooktypeid());\n    psmt.setString(6, book.getBookdesc());\n    psmt.setInt(7, book.getId());\n    return psmt.executeUpdate();\n}\n```\n\n修改成功返回1，修改失败返回0\n\n---\n\n<font color=#0cf>查询图书</font>\n\n```java\npublic static ResultSet list(Connection conn, Book book) throws SQLException {\n    StringBuffer sb = new StringBuffer(\"select * from book b,table_booktype bt where b.bookTypeId=bt.id\");\n    if (!StringUtil.isEmpty(book.getBookname())) {\n        sb.append(\" and b.bookName like \'%\" + book.getBookname() + \"%\'\");\n    }\n    if (!StringUtil.isEmpty(book.getAuthor())) {\n        sb.append(\" and b.author like \'%\" + book.getAuthor() + \"%\'\");\n    }\n    if (book.getBooktypeid() != null && book.getBooktypeid() != -1) {\n        sb.append(\" and b.bookTypeId=\" + book.getBooktypeid());\n    }\n    PreparedStatement psmt = conn.prepareStatement(sb.toString());\n    return psmt.executeQuery();\n}\n```\n\n返回查询结果\n\n---\n\n### view包\n\n视图层是利用的swing组件设计，但这个不是本项目的重点，因为Java的swing已经很少有人用了，可以直接使用idea中的`JFormDesigner`插件进行拖拉控件，使用时一定要注意将框架的布局类型设为`null Layout`，大小设为`Design size`\n\n我们只需设计按钮和表格的触发事件\n\n例如图书添加事件\n\n```java\nprivate void button1ActionPerformed(ActionEvent e) {\n    String bookName = this.booknameTXT.getText();\n    String author = this.bookAuthorTXT.getText();\n    String price = this.bookPriceTXT.getText();\n    String bookDesc = this.bookDescTXT.getText();\n    if (StringUtil.isEmpty(bookName)) {\n        JOptionPane.showMessageDialog(null, \"图书名称不能为空\");\n        return;\n    }\n    if (StringUtil.isEmpty(author)) {\n        JOptionPane.showMessageDialog(null, \"图书作者不能为空\");\n        return;\n    }\n    if (StringUtil.isEmpty(price)) {\n        JOptionPane.showMessageDialog(null, \"图书价格不能为空\");\n        return;\n    }\n    try {\n        float pricef = Float.parseFloat(price);\n    } catch (NumberFormatException numberFormatException) {\n        JOptionPane.showMessageDialog(null, \"图书价格应为数字\");\n        return;\n    }\n    String sex = \"\";\n    if (this.man.isSelected()) {\n        sex = \"男\";\n    } else {\n        sex = \"女\";\n    }\n    Booktype booktype = (Booktype) this.booktypecb.getSelectedItem();\n    assert booktype != null;\n    int booktypeId = booktype.getId();\n    Book book = new Book(bookName, author, sex, Float.parseFloat(price), booktypeId, bookDesc);\n    Connection conn = null;\n    try {\n        conn = dbUtil.getConnection();\n        int addNum = BookDao.add(conn, book);\n        if (addNum == 1) {\n            JOptionPane.showMessageDialog(null, \"添加成功\");\n            resetValue();\n        } else {\n            JOptionPane.showMessageDialog(null, \"添加失败\");\n        }\n    } catch (Exception ex) {\n        ex.printStackTrace();\n        JOptionPane.showMessageDialog(null, \"添加失败\");\n    } finally {\n        try {\n            conn.close();\n        } catch (SQLException ex) {\n            ex.printStackTrace();\n        }\n    }\n}\n```\n\n设计思想：\n\n1. 判断必需的输入框是否为空，以及类型是否一致\n2. 获取各输入框的数据\n3. 根据数据实例化对象\n4. 调用`dao`包中对应的方法进行操作\n\n其他的删除，修改，查询的操作思想基本和添加的方法一样\n\n## 项目总结\n\n项目中使用到了Java的swing技术，但是现在已经很少有人会用Java去写软件界面了，Java不能像C#那样拖拉控件设计界面，但是可以在idea中安装`JFormDesigner`插件实现C#那样的效果。\n\n>  MVC全名是Model View  Controller，是模型(model)－视图(view)－控制器(controller)的缩写，一种软件设计典范，用一种业务逻辑、数据、界面显示分离的方法组织代码，将业务逻辑聚集到一个部件里面，在改进和个性化定制界面及用户交互的同时，不需要重新编写业务逻辑。MVC被独特的发展起来用于映射传统的输入、处理和输出功能在一个逻辑的图形化用户界面的结构中。 \n\nMVC即围绕着数据库进行操作，本项目只是简单地实现了对数据库的增删改查，比较适合新手练习。', '25', '开发', 'java,mysql', '1', '4021', '0', '0', '2020-04-18 19:55:23', '2020-04-18 19:55:23');
INSERT INTO `tb_blog` VALUES ('4', '用 IDEA 进行Junit单元测试', '操作步骤  IDEA建一个Maven工程    添加Junit依赖    编写简单类    生成测试类    查看测试结果 添加Junit依赖', '### 操作步骤\n\n1.  IDEA建一个Maven工程\n2. 添加Junit依赖\n3. 编写简单类\n4. 生成测试类\n5. 查看测试结果\n\n### 添加Junit依赖\n\n```xml\n<dependency>\n    <groupId>org.junit.jupiter</groupId>\n    <artifactId>junit-jupiter-api</artifactId>\n    <version>5.5.2</version>\n    <scope>test</scope>\n</dependency>\n```\n\n本例用Junit 5进行单元测试\n\n### 简单类\n\n```java\npublic class Student {\n\n    /**\n     * id : 20171004024\n     * name : Vigilr\n     * Java : 99.0\n     * Python : 98.0\n     * JavaScript : 97.0\n     */\n\n    private long id;\n    private String name;\n    private double Java;\n    private double Python;\n    private double JavaScript;\n\n    public Student() {\n        this.id=123456789;\n        this.name=\"张三\";\n        this.Java=60.0;\n        this.Python=60.1;\n        this.JavaScript=59.9;\n    }\n\n    public long getId() {\n        return id;\n    }\n\n    public void setId(long id) {\n        this.id = id;\n    }\n\n    @Override\n    public String toString() {\n        final StringBuffer sb = new StringBuffer(\"Student{\");\n        sb.append(\"id=\").append(id);\n        sb.append(\", name=\'\").append(name).append(\'\\\'\');\n        sb.append(\", Java=\").append(Java);\n        sb.append(\", Python=\").append(Python);\n        sb.append(\", JavaScript=\").append(JavaScript);\n        sb.append(\'}\');\n        return sb.toString();\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public double getJava() {\n        return Java;\n    }\n\n    public void setJava(double Java) {\n        this.Java = Java;\n    }\n\n    public double getPython() {\n        return Python;\n    }\n\n    public void setPython(double Python) {\n        this.Python = Python;\n    }\n\n    public double getJavaScript() {\n        return JavaScript;\n    }\n\n    public void setJavaScript(double JavaScript) {\n        this.JavaScript = JavaScript;\n    }\n\n    /**\n    * 计算学生成绩总分\n    *\n    * @return double\n    * @since 2020/4/22        \n    */ \n    public double sum() {\n        return this.Java + this.Python + this.JavaScript;\n    }\n}\n\n```\n\n> 本类通过`GsonFormat`直接生成setter,getter方法，然后编写构造方法和计算总成绩方法。\n\n### 测试类\n\n快捷键<kbd>Ctrl</kbd>+<kbd>Shift</kbd>+<kbd>T</kbd>创建测试类\n\n```java\nclass StudentTest {\n\n    Student stu = null;\n\n    @BeforeEach\n    void setUp() {\n        stu = new Student();\n        System.out.println(\"开始单元测试\");\n    }\n\n    @AfterEach\n    void tearDown() {\n        System.out.println(\"结束单元测试\");\n    }\n\n    @Test\n    void getId() {\n        System.out.println(\"getId()：\" + stu.getId() + \"，测试成功\");\n    }\n\n    @Test\n    void setId() {\n        stu.setId(654321);\n        assertEquals( 654321,stu.getId(),\"setId()方法异常\");\n        System.out.println(\"setId()测试成功\");\n    }\n\n    @Test\n    void getName() {\n        System.out.println(\"getName()：\" + stu.getName() + \"，测试成功\");\n    }\n\n    @Test\n    void setName() {\n        stu.setName(\"李四\");\n        assertEquals(stu.getName(), \"李四\");\n        System.out.println(\"setName()测试成功\");\n    }\n\n    @Test\n    void getJava() {\n        System.out.println(\"Java成绩为\"+stu.getJava()+\"，测试成功\");\n    }\n\n    @Test\n    void setJava() {\n        stu.setJava(99.9);\n        assertEquals(99.9,stu.getJava(),\"setJava()方法异常\");\n        System.out.println(\"setJava()测试成功\");\n    }\n\n    @Test\n    void sum() {\n        assertEquals( 180,stu.sum(),\"sum()方法异常\");\n        System.out.println(stu);\n        System.out.println(\"张三总分为180，sum()测试成功\");\n    }\n\n}\n```\n\n### 测试结果\n\n测试成功的结果：\n\n![测试成功](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9naXRlZS5jb20vZXRlcm5pZGFkMzMvcGljYmVkL3Jhdy9tYXN0ZXIvaW1nL3N0dWRlbnR0ZXN0cy5wbmc?x-oss-process=image/format,png)\n\n测试失败的结果：\n\n![测试失败](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9naXRlZS5jb20vZXRlcm5pZGFkMzMvcGljYmVkL3Jhdy9tYXN0ZXIvaW1nL3N0dWRlbnR0ZXN0Zi5wbmc?x-oss-process=image/format,png)\n\n### Junit 5总结\n\n**注解**\n\n`@BeforeAll `只执行一次，在所有测试和 @BeforeEach 注解方法之前。 \n\n`@BeforeEach`在每个单元测试执行之前执行。 \n\n`@Test`进行单元测试\n\n`@AfterEach`在每个单元测试执行之后执行。 \n\n`@AfterAll`只执行一次，最后执行\n\n**断言**\n\n基本用法：`assertEquals(预期结果,实际测试结果,报错信息)`', '24', '日常随笔', 'idea', '1', '465', '0', '0', '2020-04-23 19:52:31', '2020-04-23 19:52:31');
INSERT INTO `tb_blog` VALUES ('5', 'Visio形状栏消失后显示', '今天再用Visio绘制状态图时一不小心把左侧的形状栏隐藏了，之后在网上找了半天才找到解决方案，（主要是自己不太会总结关键词）参考链接microsoft visio 左边的形状如何打开', '> 今天再用Visio绘制状态图时一不小心把左侧的形状栏隐藏了，之后在网上找了半天才找到解决方案，（主要是自己不太会总结关键词）参考链接[microsoft visio 左边的形状如何打开](https://zhidao.baidu.com/question/106430461.html)\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200518200555359.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyOTA3ODAy,size_16,color_FFFFFF,t_70)解决方案：\n1. 选择视图按钮\n2. 单击任务窗格，选择形状\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200518201059594.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyOTA3ODAy,size_16,color_FFFFFF,t_70)\n4. 显示效果![在这里插入图片描述](https://img-blog.csdnimg.cn/20200518201407379.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyOTA3ODAy,size_16,color_FFFFFF,t_70)', '24', '日常随笔', 'visio', '1', '1014', '0', '0', '2020-05-18 20:14:31', '2020-05-18 20:14:31');
INSERT INTO `tb_blog` VALUES ('6', 'selenium+sqlalchemy 爬取京东商品信息并存入MySQL', '导入必要的包 # 浏览器驱动 from selenium import webdriver# 模拟键盘按键操作\r\nfrom selenium.webdriver.common.keys import Keys', '## 导入必要的包\n\n\n```python\n# 浏览器驱动\nfrom selenium import webdriver\n# 模拟键盘按键操作\nfrom selenium.webdriver.common.keys import Keys\n# 用于设置休眠和获取时间\nimport time\n# 数据库相关\nfrom sqlalchemy import create_engine, Integer,String,Float\nfrom sqlalchemy.orm import sessionmaker\nfrom sqlalchemy.ext.declarative import declarative_base\nfrom sqlalchemy import Column\n```\n\n## 自动打开火狐浏览器\n\n用火狐浏览器需将驱动设置为`webdriver.Firefox()`，火狐浏览器驱动还需在[GitHub](https://github.com/mozilla/geckodriver/releases)下载geckodriver，并解压到Anaconda3\\Scripts目录下(也可单独添加到环境变量中)，用于启动浏览器\n\n用谷歌浏览器同理，将驱动设置为`webdriver.Chrome()`需下载，可以从[chromium站点](https://sites.google.com/a/chromium.org/chromedriver/downloads)下载，同时添加到环境变量中\n\n> 驱动版本一定要和浏览器版本相匹配\n\n\n```python\nkeyword=\'电脑\'\ndriver=webdriver.Firefox()\n# driver=webdriver.Chrome()\ndriver.get(\'https://www.jd.com\')\nkey=driver.find_element_by_id(\'key\')\nkey.send_keys(keyword)\nkey.send_keys(Keys.RETURN)\n```\n\n## 设置排序方式\n\n可以设置按销量排序，也可以不设置，直接综合排序，按销量排序时，应该等到出现限量按钮才可以点击，可通过设置休眠时间解决。\n\n\n```python\n# 按销量排序\n# 设置休眠时间\ntime.sleep(3)\nsort_btn=driver.find_element_by_xpath(\'.//div[@class=\"f-sort\"]/a[2]\')\nsort_btn.click()\n```\n\n## 获取商品列表的长度\n\n滑动到翻页位置，用于模拟点击下一页\n\n\n```python\ngoods_list=driver.find_element_by_id(\'J_goodsList\')\nh=(goods_list.rect[\'y\']+goods_list.rect[\'height\'])\ntime.sleep(1)\ndriver.execute_script(\'window.scrollTo(0,%s)\'%h)\n```\n\n## 获取所有的商品标签\n\n\n```python\nproducts=driver.find_elements_by_class_name(\'gl-item\')\nlen(products)\n```\n\n\n    30\n\n## 爬取第一件商品\n\n可通过id，标签，CSS，类选择器获取相关信息\n\n\n```python\ntime.sleep(3)\n# 获取商品sku\np=products[0]\nsku=p.get_attribute(\'data-sku\')\nsku\n```\n\n\n    \'100012950122\'\n\n京东商品的连接可通过sku获取，例如sku为\'100008348538\'，该商品的链接为https://item.jd.com/100008348538.html\n\n格式为`https://item.jd.com/`+`sku`+`.html`\n\n\n```python\n# 爬取价格\nprice=p.find_element_by_class_name(\'p-price\').text\nprice\n```\n\n\n    \'￥4489.00\'\n\n\n```python\n# 爬取名称\nname=p.find_element_by_css_selector(\'div.p-name\').text\nname\n```\n\n\n    \'联想(Lenovo)天逸510S 英特尔酷睿i5 个人商务台式机电脑主机(i5-9400 16G 1T+256G SSD WiFi Win10)23英寸\'\n\n\n```python\n# 爬取评价数量\ncommentcount=p.find_element_by_id(\'J_comment_%s\'%sku).text\ncommentcount\n```\n\n\n    \'2700+\'\n\n\n```python\n# 爬取店铺\nshop=p.find_element_by_class_name(\'p-shop\').text\nshop\n```\n\n\n    \'联想京东自营旗舰店\'\n\n\n```python\n# 爬取封面图片\nu=p.find_element_by_tag_name(\'img\').get_attribute(\'src\')\nu\n```\n\n\n    \'https://img12.360buyimg.com/n7/jfs/t1/128291/24/552/56550/5eb65126E0f5ebeb1/fc0e83834d771cf8.jpg\'\n\n\n```python\n# 保存图片\nimport urllib\nurllib.request.urlretrieve(u,\'img/\'+sku+\'.jpg\')\n```\n\n\n    (\'img/100012950122.jpg\', <http.client.HTTPMessage at 0x188aa79f5c8>)\n\n## 将数据存储到数据库\n\n\n```python\n# 创建数据库的连接\nengine = create_engine(\"mysql+pymysql://root:123456@127.0.0.1:3308/xymall?charset=utf8\")\n# 操作数据库，创建一个session\nSession = sessionmaker(bind=engine)\n# 声明一个基类\nBase = declarative_base()\n```\n\n\n```python\n# 定义表结构\nclass jdPCTest(Base):\n    __tablename__=\'jdPCTest\'\n    id = Column(Integer,primary_key=True,autoincrement=True)\n    sku = Column(String(length=50),nullable=True)\n    name = Column(String(length=500),nullable=False)\n    price = Column(String(length=20),nullable=False)\n    comment=Column(String(length=20),nullable=False)\n    shop=Column(String(length=20),nullable=False)\n    date=Column(String(length=20),nullable=False)\n```\n\n\n```python\n# 创建数据表\njdPCTest.metadata.create_all(engine)\n```\n\n```python\nmysqlSession=Session()\n# 日期\ndate = time.strftime(\"%Y-%m-%d\",time.localtime())\n# 存储的数据结构\ndata = jdPCTest(\n    sku=sku,\n    name=name,\n    price=price,\n    comment=commentcount,\n    shop=shop,\n    date=date\n)\nmysqlSession.add(data)\nmysqlSession.commit()\n```\n\n> 本文件为 jupyter Notebook导出文件，源文件可从[码云](https://gitee.com/xy221/mall/tree/master/crawlData)下载', '25', '开发', 'mysql,python,selenium', '1', '394', '0', '0', '2020-06-04 19:54:21', '2020-06-04 19:54:21');
INSERT INTO `tb_blog` VALUES ('7', '阿里云宝塔面板配置及部署Java项目', '阿里云宝塔面板配置及部署Java项目 购买服务器 直接购买就可以了 有活动时购买比较便宜，我记得曾经有个活动是70一年的服务器 现在购买可以91.8一年 ', '# 阿里云宝塔面板配置及部署Java项目\n\n## 购买服务器\n\n直接购买就可以了\n\n有活动时购买比较便宜，我记得曾经有个活动是70一年的服务器\n\n现在购买可以91.8一年\n![](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL2V0ZXJuaWRhZDMzL3BpY2JlZEBtYXN0ZXIvaW1nL2FsaXl1bjkxLjgucG5n?x-oss-process=image/format,png#pic_center)\n\n学生购买是9.50一个月（参与[云翼计划](https://promotion.aliyun.com/ntms/act/campus2018.html)然后学生认证即可）\n\n> 我是单买的一个月的，因为不经常用，想用的时候就买一个月的\n\n## 安装镜像\n\n从镜像市场选择宝塔控制面板安装\n\n![宝塔](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL2V0ZXJuaWRhZDMzL3BpY2JlZEBtYXN0ZXIvaW1nLyVFNSVBRSU5RCVFNSVBMSU5NC5wbmc?x-oss-process=image/format,png#pic_center)\n\n> [宝塔Linux面板（LAMP/LNMP/Tomcat/Node.js）](https://market.aliyun.com/products/53690006/cmjj015022.html)\n>\n> 功能强大且终身免费的Linux服务器管理软件，一键部署：LAMP/LNMP/Tomcat/Node.js、网站、数据库、FTP、SSL，通过Web端轻松管理服务器。\n\n镜像安装完要配置安全组打开相应端口\n\n![安全组](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL2V0ZXJuaWRhZDMzL3BpY2JlZEBtYXN0ZXIvaW1nLyVFNSVBRSU4OSVFNSU4NSVBOCVFNyVCQiU4NC5wbmc?x-oss-process=image/format,png#pic_center)\n\n## 面板配置\n\n`bt`命令进行相关的操作\n\n![bt](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL2V0ZXJuaWRhZDMzL3BpY2JlZEBtYXN0ZXIvaW1nL2J0LnBuZw?x-oss-process=image/format,png#pic_center)\n\n可以更改掉默认的用户名和密码\n\n浏览器访问`公网ip:8888`进行环境的安装\n\n![面板首页](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL2V0ZXJuaWRhZDMzL3BpY2JlZEBtYXN0ZXIvaW1nLyVFOSU5RCVBMiVFNiU5RCVCRiVFOSVBNiU5NiVFOSVBMSVCNS5wbmc?x-oss-process=image/format,png#pic_center)\n\n可以选择LNMP安装，大约5~6分钟安装完成\n\n![已安装软件](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL2V0ZXJuaWRhZDMzL3BpY2JlZEBtYXN0ZXIvaW1nLyVFNSVCNyVCMiVFNSVBRSU4OSVFOCVBMyU4NSVFOCVCRCVBRiVFNCVCQiVCNi5wbmc?x-oss-process=image/format,png#pic_center)\n\n配置mysql数据库相应的端口，默认3306，可以改为其他端口\n\n安装完成后可以数据库的root密码\n\n## 安装Tomcat\n\n从左侧的软件商店安装Tomcat（不用单独安装Java，面板自动安装Java）\n\n安装完tomcat后要在面板中放行8080端口，前边的安全组也要放行8080端口\n\n![面板防火墙](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL2V0ZXJuaWRhZDMzL3BpY2JlZEBtYXN0ZXIvaW1nLyVFOSU5RCVBMiVFNiU5RCVCRiVFOSU5OCVCMiVFNyU4MSVBQiVFNSVBMiU5OS5wbmc?x-oss-process=image/format,png#pic_center)\n\n浏览器成功访问`公网ip:8080`，即为成功安装\n\n![tomcat9](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL2V0ZXJuaWRhZDMzL3BpY2JlZEBtYXN0ZXIvaW1nL3RvbWNhdDkucG5n?x-oss-process=image/format,png#pic_center)\n\n## 部署项目\n\n本文部署的是[GitHub](https://github.com/MccreeFei/EasyChat)上的 一个基于SSM+Websocket的实时在线聊天室项目 \n\n配置数据库信息并生成war包\n\n![生成WAR包](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL2V0ZXJuaWRhZDMzL3BpY2JlZEBtYXN0ZXIvaW1nLyVFNyU5NCU5RiVFNiU4OCU5MFdBUiVFNSU4QyU4NS5wbmc?x-oss-process=image/format,png#pic_center)\n\n成功生成war包后的效果如下：\n\n![war生成成功](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL2V0ZXJuaWRhZDMzL3BpY2JlZEBtYXN0ZXIvaW1nL3dhciVFNyU5NCU5RiVFNiU4OCU5MCVFNiU4OCU5MCVFNSU4QSU5Ri5wbmc?x-oss-process=image/format,png#pic_center)\n\n在服务器的mysql运行本项目中的sql文件\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200616133230949.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyOTA3ODAy,size_16,color_FFFFFF,t_70#pic_center)\n\n将生成的war文件上传到`/www/server/tomcat/webapps`目录下，tomcat会自动解压\n\n![wabapps](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL2V0ZXJuaWRhZDMzL3BpY2JlZEBtYXN0ZXIvaW1nL3dhYmFwcHMucG5n?x-oss-process=image/format,png#pic_center)\n\n> 上传文件方法有很多，可以通过命令行，也可以用工具，我知道的工具如下：\n>\n> 1. xshell及xftp\n> 2. IDEA的阿里云部署插件(Alibaba Cloud Toolkit)\n> 3. 通过宝塔面板上传\n\n浏览器访问[公网IP:8080/网站应用名](http://112.124.30.121:8080/easy-chat/)，出现下面的界面即为成功部署\n\n![easychat部署](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL2V0ZXJuaWRhZDMzL3BpY2JlZEBtYXN0ZXIvaW1nL2Vhc3ljaGF0JUU5JTgzJUE4JUU3JUJEJUIyLnBuZw?x-oss-process=image/format,png#pic_center)\n\n> 文章如果有什么错误的地方，欢迎大家评论留言', '24', '日常随笔', 'java', '1', '3091', '0', '0', '2020-06-16 10:05:38', '2020-06-16 10:05:38');
INSERT INTO `tb_blog` VALUES ('8', '本地添加多个ssh公钥', '在一台电脑上生成多个公钥格式ssh-keygen -t rsa -C 邮箱 公钥名 例如：ssh-keygen -t rsa -C \"456@qq.com\" -f ~/.ssh/id_github_vigilr ssh-keygen -t rsa -C \"123@qq.com\" -f ~/.ssh/id_gitee_vigilr', '在一台电脑上生成多个公钥格式`ssh-keygen -t rsa -C 邮箱 公钥名`\n\n例如：\n```bash\nssh-keygen -t rsa -C \"456@qq.com\" -f ~/.ssh/id_github_vigilr\nssh-keygen -t rsa -C \"123@qq.com\" -f ~/.ssh/id_gitee_vigilr\n```\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200616215715910.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyOTA3ODAy,size_16,color_FFFFFF,t_70)\n> ssh路径一般是在.ssh文件夹里的\n\n配置.ssh文件夹下的config文件（如果没有就新建一个，没有后缀）\n\nconfig文件内容如下：\n```bash\n# 配置github.com\n\nHost github.com               \n\n    HostName github.com\n\n    IdentityFile C:\\\\Users\\\\Administrator\\\\.ssh\\\\id_github_vigilr\n\n# 配置gitee\n\nHost gitee.com\n    \n    HostName gitee.com\n    \n    IdentityFile C:\\\\Users\\\\Administrator\\\\.ssh\\\\id_gitee_vigilr\n    \n```\n\n最后把对应的公钥（后缀为.pub文件的内容）放在GitHub或者gitee即可', '24', '日常随笔', 'ssh', '1', '666', '0', '0', '2020-06-16 22:09:45', '2020-06-16 22:09:45');
INSERT INTO `tb_blog` VALUES ('9', 'TCP与UDP编程', 'Socket是网络编程的一个抽象概念。通常我们用一个Socket表示“打开了一个网络链接”，而打开一个Socket需要知道目标计算机的IP地址和端口号，再指定协议类型即可。客户端 操作步骤    创建socket    建立连接    接收服务端数据    发送数据    断开连接', '> Socket是网络编程的一个抽象概念。通常我们用一个Socket表示“打开了一个网络链接”，而打开一个Socket需要知道目标计算机的IP地址和端口号，再指定协议类型即可。\n## 客户端\n**操作步骤**\n1. 创建socket\n2. 建立连接\n3. 接收服务端数据\n4. 发送数据\n5. 断开连接\n```python\n# 客户端代码\nimport socket\ns = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n# 建立连接:\ns.connect((\'127.0.0.1\', 9999))\n# 接收欢迎消息:\nprint(s.recv(1024).decode(\'utf-8\'))\nfor data in [b\'Michael\', b\'Tracy\', b\'Sarah\']:\n    # 发送数据:\n    s.send(data)\n    print(s.recv(1024).decode(\'utf-8\'))\ns.send(b\'exit\')\ns.close()\n```\n## 服务端\n**操作步骤**\n1. 创建socket\n2. 绑定监听端口\n3. 多线程接收客户端连接\n4. 数据接收与发送\n\n```python\nimport socket,threading,time\ns = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n\n# 监听端口:\ns.bind((\'127.0.0.1\', 9999))\n\ns.listen(5)\nprint(\'Waiting for connection...\')\n\n# 每个连接都必须创建新线程（或进程）来处理，\n# 否则，单线程在处理连接的过程中，无法接受其他客户端的连接：\ndef tcplink(sock, addr):\n    print(\'Accept new connection from %s:%s...\' % addr)\n    sock.send(b\'Welcome!\')\n    while True:\n        data = sock.recv(1024)\n        time.sleep(1)\n        if not data or data.decode(\'utf-8\') == \'exit\':\n            break\n        sock.send((\'Hello, %s!\' % data.decode(\'utf-8\')).encode(\'utf-8\'))\n    sock.close()\n    print(\'Connection from %s:%s closed.\' % addr)\n    \nwhile True:\n    # 接受一个新连接:\n    sock, addr = s.accept()\n    # 创建新线程来处理TCP连接:\n    t = threading.Thread(target=tcplink, args=(sock, addr))\n    t.start()\n```\n运行截图\n\n服务端：\n![服务端](https://img-blog.csdnimg.cn/20200617192107243.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyOTA3ODAy,size_16,color_FFFFFF,t_70)\n客户端：\n![客户端](https://img-blog.csdnimg.cn/20200617192107226.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyOTA3ODAy,size_16,color_FFFFFF,t_70)\n## UDP\nTCP是建立可靠连接，并且通信双方都可以以流的形式发送数据。相对TCP，UDP则是面向无连接的协议。\n\n使用UDP协议时，不需要建立连接，只需要知道对方的IP地址和端口号，就可以直接发数据包。但是，能不能到达就不知道了。\n\n虽然用UDP传输数据不可靠，但它的优点是和TCP比，速度快，对于不要求可靠到达的数据，就可以使用UDP协议。\n\n我们来看看如何通过UDP协议传输数据。和TCP类似，使用UDP的通信双方也分为客户端和服务器。服务器首先需要绑定端口：\n```python\ns = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n# 绑定端口:\ns.bind((\'127.0.0.1\', 9999))\n```\n\n创建Socket时，`SOCK_DGRAM`指定了这个Socket的类型是UDP。绑定端口和TCP一样，但是不需要调用`listen()`方法，而是直接接收来自任何客户端的数据：\n```python\nprint(\'Bind UDP on 9999...\')\nwhile True:\n    # 接收数据:\n    data, addr = s.recvfrom(1024)\n    print(\'Received from %s:%s.\' % addr)\n    s.sendto(b\'Hello, %s!\' % data, addr)\n ```\n\n`recvfrom()`方法返回数据和客户端的地址与端口，这样，服务器收到数据后，直接调用`sendto()`就可以把数据用UDP发给客户端。\n\n\n客户端使用UDP时，首先仍然创建基于UDP的Socket，然后，不需要调用`connect()`，直接通过`sendto()`给服务器发数据：\n```python\ns = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\nfor data in [b\'Michael\', b\'Tracy\', b\'Sarah\']:\n    # 发送数据:\n    s.sendto(data, (\'127.0.0.1\', 9999))\n    # 接收数据:\n    print(s.recv(1024).decode(\'utf-8\'))\ns.close()\n```\n从服务器接收数据仍然调用`recv()`方法。', '25', '开发', 'python', '1', '482', '0', '0', '2020-06-17 20:29:28', '2020-06-17 20:29:28');
INSERT INTO `tb_blog` VALUES ('10', '自定义自己的GitHub主页', '虽然代码不怎么写，但是逼格不能丢 直接看演示效果', '> 虽然代码不怎么写，但是逼格不能丢\n\n直接看演示效果\n\n![演示效果](https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xODc4MDIyNi1mMWQ1Y2Q1NjJmNmVjMTExLnBuZw?x-oss-process=image/format,png)\n\n创建以用户名为名称的仓库\n自定义自己的 README 文件即可在自己的 github 显示了\n\n我这个上边显示的编码时长，是添加了一个 action 每天更新自己的编码时长\n具体设计步骤可参考 github 上的[athul/waka-readme](https://github.com/athul/waka-readme)项目\n\n总结一下简要的步骤\n\n1. 注册 wakatime 账号\n2. 在自己常用的 IDE 上下载 wakatime 插件，配置上自己的 API key\n3. 将自己的 API key 存到自己 GitHub 仓库的 secrets\n4. 在 README 文件上加上\n\n```markdown\n  <!--START_SECTION:waka-->\n  <!--END_SECTION:waka-->\n```\n\n5. 配置 GitHub 仓库的 Action，这样就能每天自动运行了\n\n欢迎大家访问我的[github](https://github.com/eternidad33)', '24', '日常随笔', 'github', '1', '810', '0', '0', '2020-07-20 15:38:30', '2020-07-20 15:38:30');
INSERT INTO `tb_blog` VALUES ('11', '历年 CCF CSP 认证部分题解', '源码已上传至码云和GitHub\r\n\r\n2021/1/8 更新\r\n\r\n由于我在 CSDN 关于 CSP 题解的文章杂乱无章，今天闲来无事，于是就把我的博客文章重新整理了一下，题解详情已通过docsify部署到了码云和GitHub\r\nJava 题解 试题编号	试题名称	最高得分 202006-1	线性分类器	100 201912-1	报数	100 201909-1	小明种苹果	100 201903-1	小中大	100 201812-1	小明上学	100 201809-1	卖菜	100', '> 源码已上传至[码云](https://gitee.com/eternidad33/csp)和[GitHub](https://github.com/eternidad33/csp)\n\n**2021/1/8 更新**\n\n由于我在 CSDN 关于 CSP 题解的文章杂乱无章，今天闲来无事，于是就把我的博客文章重新整理了一下，题解详情已通过`docsify`部署到了[码云](https://eternidad33.gitee.io/csp/)和[GitHub](https://eternidad33.gitee.io/csp/#/)\n\n**Java 题解**\n\n| 试题编号 |                                  试题名称                                   | 最高得分 |\n| :------: | :-------------------------------------------------------------------------: | :------: |\n| 202006-1 |       [线性分类器](https://eternidad33.gitee.io/csp/#/csp/线性分类器)       |   100    |\n| 201912-1 |             [报数](https://eternidad33.gitee.io/csp/#/csp/报数)             |   100    |\n| 201909-1 |       [小明种苹果](https://eternidad33.gitee.io/csp/#/csp/小明种苹果)       |   100    |\n| 201903-1 |           [小中大](https://eternidad33.gitee.io/csp/#/csp/小中大)           |   100    |\n| 201812-1 |         [小明上学](https://eternidad33.gitee.io/csp/#/csp/小明上学)         |   100    |\n| 201809-1 |             [卖菜](https://eternidad33.gitee.io/csp/#/csp/卖菜)             |   100    |\n| 201803-1 |           [跳一跳](https://eternidad33.gitee.io/csp/#/csp/跳一跳)           |   100    |\n| 201712-1 |         [最小差值](https://eternidad33.gitee.io/csp/#/csp/最小差值)         |   100    |\n| 201709-1 |           [打酱油](https://eternidad33.gitee.io/csp/#/csp/打酱油)           |   100    |\n| 201703-1 |           [分蛋糕](https://eternidad33.gitee.io/csp/#/csp/分蛋糕)           |   100    |\n| 201612-1 |           [中间数](https://eternidad33.gitee.io/csp/#/csp/中间数)           |   100    |\n| 201609-1 |         [最大波动](https://eternidad33.gitee.io/csp/#/csp/最大波动)         |   100    |\n| 201604-1 |         [折点计数](https://eternidad33.gitee.io/csp/#/csp/折点计数)         |   100    |\n| 201512-1 |         [数位之和](https://eternidad33.gitee.io/csp/#/csp/数位之和)         |   100    |\n| 201509-1 |         [数列分段](https://eternidad33.gitee.io/csp/#/csp/数列分段)         |   100    |\n| 201503-1 |         [图像旋转](https://eternidad33.gitee.io/csp/#/csp/图像旋转)         |   100    |\n| 201412-1 |         [门禁系统](https://eternidad33.gitee.io/csp/#/csp/门禁系统)         |   100    |\n| 201409-1 |         [相邻数对](https://eternidad33.gitee.io/csp/#/csp/相邻数对)         |   100    |\n| 201403-1 |           [相反数](https://eternidad33.gitee.io/csp/#/csp/相反数)           |   100    |\n| 201312-1 | [出现次数最多的数](https://eternidad33.gitee.io/csp/#/csp/出现次数最多的数) |   100    |\n\n\n**Python 题解**\n\n- [第 1 题](https://eternidad33.gitee.io/csp/#/csp/py1)\n- [第 2 题](https://eternidad33.gitee.io/csp/#/csp/py2)\n- [第 3 题](https://eternidad33.gitee.io/csp/#/csp/py3)', '24', '日常随笔', 'java,python', '1', '858', '0', '0', '2020-08-07 09:20:24', '2020-08-07 09:20:24');
INSERT INTO `tb_blog` VALUES ('12', '牛客高赞评论整理', '      本文总结在牛客刷题过程中，遇到的错题及相关的高赞评论解析。  数据结构  对n个记录的文件进行快速排序，所需要的辅助存储空间大致为', '> 本文总结在牛客刷题过程中，遇到的错题及相关的高赞评论解析。\n\n## 数据结构\n**[对n个记录的文件进行快速排序，所需要的辅助存储空间大致为](https://www.nowcoder.com/questionTerminal/d4d3b9e4c5974aae869ce1fd61fd8c8a)**\n\n```\n正确答案: C   你的答案: C\n\nA、O（1）\nB、O（n）\nC、O（1og2n）\nD、O（n2）\n```\n\n辅助存储空间 = 时间复杂度 \n额外存储空间 = 空间复杂度\n\n快速排序对待排序序列得划分大约是log<sub>2</sub>n次，因为快速排序是通过递归算法来实现的，递归深度大约是log<sub>2</sub>n，所以所需得辅助空间为log<sub>2</sub>n\n\n---\n\n**[基于比较的排序算法是（ ）](https://www.nowcoder.com/questionTerminal/5a7581e365d94db0966ab808ce304928)**\n\n```\n正确答案: B D  你的答案: B D\n\nA、基数排序\nB、冒泡排序\nC、桶排序\nD、希尔排序\n```\n\n1、基于比较的排序算法有：（1）直接插入排序；（2）冒泡排序；（3）简单选择排序；（4）希尔排序；（5）快速排序；（6）堆排序；（7）归并排序。 \n\n2、基数排序、桶排序都属于分配式排序，且都是稳定排序算法。 \n\n---\n\n**[待排序元素规模较小时，宜选取哪种排序算法效率最高（   ）](https://www.nowcoder.com/questionTerminal/a95f7e2431174ed69422df4b5354113a)**\n\n```\n正确答案: C  你的答案: C\n\nA、堆排序\nB、归并排序\nC、冒泡排序\nD、希尔排序\n```\n笔记：递归时间可能长于比较时间\n\n---\n\n**[下面有关P问题，NP问题和NPC问题，说法错误的是](https://www.nowcoder.com/questionTerminal/8b52ba2d570545fdae8ee1f7cb264ec1)**\n\n```\n正确答案: D  你的答案: D\n\nA、如果一个问题可以找到一个能在多项式的时间里解决它的算法，那么这个问题就属于P问题\nB、NP问题是指可以在多项式的时间里验证一个解的问题\nC、所有的P类问题都是NP问题\nD、NPC问题不一定是个NP问题，只要保证所有的NP问题都可以约化到它即可\n```\n\n\nP:   能在多项式时间内解决的问题\n\nNP: 不能在多项式时间内解决或不确定能不能在多项式时间内解决，但能在多项式时间验证的问题\n\nNPC: NP完全问题，所有NP问题在多项式时间内都能约化(Reducibility)到它的NP问题，即解决了此NPC问题，所有NP问题也都得到解决。\n\nNP hard:NP难问题， 所有NP问题在多项式时间内都能约化(Reducibility)到它的问题(不一定是NP问题)。\n\n---\n\n**[int main(){fork()||fork();}共创建几个进程：](https://www.nowcoder.com/questionTerminal/b8321978323c43c694a561d151e69fd0)**\n\n```\n正确答案: C   你的答案: C\n\nA、1\nB、2\nC、3\nD、4\nE、5\nF、6\n```\n\n`fork()`给子进程返回一个零值，而给父进程返回一个非零值； \n\n在main这个主进程中，首先执行  `fork()|| fork()`,  左边的fork()返回一个非零值，根据`||`的短路原则，前面的表达式为真时，后面的表达式不执行，故包含main的这个主进程创建了一个子进程，由于子进程会复制父进程，而且子进程会根据其返回值继续执行，就是说，在子进程中，`fork()||fork()`这条语句左边表达式的返回值是0,  所以`||`右边的表达式要执行，这时在子进程中又创建了一个进程，即main进程->子进程->子进程，一共创建了3个进程。 \n\n## 操作系统\n\n**[以下哪个命令用于查看tar（backup.tar）文件的内容而不提取它?（）](https://www.nowcoder.com/questionTerminal/4e632ee9fb3c45e2bad336236b5ef3a9)** \n\n```\n正确答案: B  你的答案: B\n\nA、tar -xvf backup.tar\nB、tar -tvf backup.tar\nC、tar -svf backup.tar\nD、none of these\n```\n\n**[linux中tar命令用法](https://www.cnblogs.com/newcaoguo/p/5896975.html)**\n\n1. *.tar 用 tar –xvf 解压 \n2. *.gz 用 gzip -d或者gunzip 解压     \n3. \\*.tar.gz和*.tgz 用 tar –xzf 解压     \n4. *.bz2 用 bzip2 -d或者用bunzip2 解压     \n5. *.tar.bz2用tar –xjf 解压     \n6. *.Z 用 uncompress 解压     \n7. *.tar.Z 用tar –xZf 解压     \n8. *.rar 用 unrar e解压     \n9. *.zip 用 unzip 解压\n\n---\n\n**[下列说法中，错误的是（）](https://www.nowcoder.com/questionTerminal/35ad5448a793489d90d197823c879195)** \n\n```\n正确答案: D  你的答案: D\n\nA、指令就是命令，它用来规定CPU执行什么操作\nB、指令是构成程序的基本单位，程序是由一连串指令组成的\nC、指令采用二进位表示\nD、指令一般由4个部分组成\n```\n\n> 指令一般由两部分组成：\n> 操作码：该指令完成操作的类型或性质 \n> 地址码：操作对象的地址 \n\n---\n\n**[有作业控制块JCB连成一串而形成的排队队列称为（）。](https://www.nowcoder.com/questionTerminal/489c515483794a789dc303aee0e6ebc8)**\n\n```\n正确答案: D  你的答案: D\n\nA、挂起队列\nB、阻塞队列\nC、就绪队列\nD、后备队列\n```\n\n高级调度：从后备作业队列（作业控制块）中将作业调入进就绪进程队列，所以作业控制块中存放的是后背作业队列。 \n\n中级调度：是为了提高内存的使用率，将一些暂时不能运行的进程从内存移动到外存上去，即内存外出不断交换，所以中级调度会涉及到虚拟存储器。暂时不能运行的进程，由就绪挂起队列，阻塞挂起队列。而阻塞队列里的进程会由于等待时间过长自动调入到阻塞挂起队列里面去。 \n\n低级调度（短程调度）分两类，非抢占式调度和抢占式调度，从就绪进程队列中选取合适进程送到CPU上运行。 \n\n---\n\n**[死锁的预防方法中，不太可能的一种方法是（ ）。](https://www.nowcoder.com/questionTerminal/93cf7ebf8e074a7c9f0a36254391afd4)**\n\n```\n正确答案: A  你的答案: A\n\nA、摒弃互斥条件\nB、摒弃请求和保持条件\nC、摒弃不剥夺条件\nD、摒弃环路等待条件\n```\n\n1. 互斥条件：一个资源每次只能被一个进程使用。**不可破坏**  \n\n2. 请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。**一次性分配：要么全给，要么啥也不给。**\n\n3. 不剥夺条件:进程已获得的资源，在末使用完之前，不能强行剥夺。 **设置优先级，高优先级可要求低优先级让出资源。**\n\n4. 循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。**对资源进行编号，按照编号顺序申请访问**\n\n---\n\n**[下列性质中，哪一个不是分时系统的特征（）。](https://www.nowcoder.com/questionTerminal/19cba64765944273a5d8938e165e26b0)**\n\n```\n正确答案: C  你的答案: C\n\nA、交互性\nB、多路性\nC、成批性\nD、独占性\n```\n\n分时系统具有多路性、交互性、独占性和及时性的特征。\n\n多路性指，伺时有多个用户使用一台计算机，宏观上看是多个人同时使用一个CPU，微观上是多个人在不同时刻轮流使用CPU。\n\n交互性是指，用户根据系统响应结果进一步提出新请求(用户直接干预每一步)。\n\n独占性是指，用户感觉不到计算机为其他人服务，就像整个系统为他所独占。\n\n及时性指，系统对用户提出的请求及时响应。  \n\n**实时操作系统**基本特征：及时性，可靠性 \n\n\n---\n\n**[关于总线的说法中正确的是(  )](https://www.nowcoder.com/questionTerminal/15f2927d582a48c4b1677d7b9e0342ea)**\n\n```\n正确答案: A  你的答案: A\n\nA、总线是用于连接CPU、内存、外存和各种I/O设备并在它们之间传输信息的一组共享的传输线及其控制电路\nB、I/O总线是用于连接CPU和内存的总线\nC、CPU总线是连接内存和I/O设备（包括外存）的总线\nD、计算机总线中只包含CPU总线\n```\n\n**总线按功能和规范可分为五大类型:**\n\n- 数据总线(Data Bus):在CPU与RAM之间来回传送需要处理或是需要储存的数据。  \n- 地址总线(Address Bus):用来指定在RAM(Random Access Memory)之中储存的数据的地址。  \n- 控制总线(Control Bus):将微处理器控制单元(Control Unit)的信号，传送到周边设备，一般常见的为USB Bus和1394 Bus。  \n- 扩展总线(Expansion Bus):可连接扩展槽和电脑。  \n- 局部总线(Local Bus):取代更高速数据传输的扩展总线。\n\n## 数据库\n\n**[在mysql中，以下哪种方式可以开启一个事务？](https://www.nowcoder.com/questionTerminal/018e6413d33f403384f0a4aa980f6bf5)**\n\n```\n正确答案: A C  你的答案: A C\n\nA、START TRANSACTION\nB、START\nC、BEGIN\nD、BEIGN TRANSACTION\n```\n\n- BEGIN或START TRANSACTION；显示地开启一个事务\n- COMMIT；也可以使用COMMIT    WORK，不过二者是等价的。COMMIT会提交事务，并使已对数据库进行的所有修改称为永久性的  \n- ROLLBACK；有可以使用ROLLBACK    WORK，不过二者是等价的。回滚会结束用户的事务，并撤销正在进行的所有未提交的修改\n- SAVEPOINT    identifier；SAVEPOINT允许在事务中创建一个保存点，一个事务中可以有多个SAVEPOINT\n- RELEASE SAVEPOINT    identifier；删除一个事务的保存点，当没有指定的保存点时，执行该语句会抛出一个异常\n- ROLLBACK TO identifier；把事务回滚到标记点\n- SET TRANSACTION；用来设置事务的隔离级别。InnoDB存储引擎提供事务的隔离级别有READ    UNCOMMITTED、READ COMMITTED、REPEATABLE READ和SERIALIZABLE。\n\n---\n\n**[下列四项中，不属于数据库系统的主要特点的是（   ）。](https://www.nowcoder.com/questionTerminal/800eecdc01a240228910fb48f42087a6)**\n\n```\n正确答案: D  你的答案: D\n\nA、数据结构化\nB、数据的冗余度小\nC、较高的数据独立性\nD、程序的标准化\n```\n\n> 数据库系统的特点 数据结构化 数据共享性高,冗余度低,易扩充 数据独立性高\n\n---\n\n**[下面有关sql 语句中 delete truncate的说法正确的是？（）](https://www.nowcoder.com/questionTerminal/f3053b1c256e471b99a2a7da445a6d47)**\n\n```\n正确答案: A C  你的答案: A C\n\nA、论清理表数据的速度，truncate一般比delete更快\nB、truncate命令可以用来删除部分数据。\nC、truncate只删除表的数据不删除表的结构\nD、delete能够回收高水位\n```\n\n1. 处理效率：drop>trustcate>delete    \n2. drop删除整个表；trustcate删除全部记录，但不删除表；delete删除部分记录    \n3. delete不影响所用extent，高水线保持原位置不动；trustcate会将高水线复位。  \n\n## 计算机网络\n\n\n**[下面对http状态码描述正确的是？（）](https://www.nowcoder.com/questionTerminal/a8e19032005f470f96e1f6c0dde1f1e4)**\n\n```\n正确答案: A D  你的答案: A D\n\nA、1**：这类响应是临时响应，只包含状态行和某些可选的响应头信息，并以空行结束\nB、3**：表示服务端无法响应\nC、4**：表示服务端错误\nD、5**：表示服务器端错误\n```\n\n1XX（信息状态码）接受请求正在处理\n2XX（成功状态码） 请求正常处理完毕\n3XX（重定向状态码） 需要附加操作已完成请求\n4XX（客户端错误状态码） 服务器无法处理请求\n5XX（服务器错误状态码） 服务器处理请求出错\n\n---\n\n**[RPC、SQL、NFS属于OSI的哪一层？](https://www.nowcoder.com/questionTerminal/7cf6990ea2e345b6bc96d882944c4d6b)**\n\n```\n正确答案: C  你的答案: C\n\nA、应用层\nB、表示层\nC、会话层\nD、传输层\n```\n\n> 第一层：物理层\n> 第二层：数据链路层 802.2、802.3ATM、HDLC、FRAME RELAY \n> 第三层：网络层 IP、IPX、APPLETALK、ICMP \n> 第四层：传输层 TCP、UDP、SPX \n> 第五层：会话层 RPC、SQL、NFS 、X WINDOWS、ASP\n> 第六层：表示层 ASCLL、PICT、TIFF、JPEG、 MIDI、MPEG \n> 第七层：应用层 HTTP、FTP、SNMP等\n\n\n## Java\n\n**[下列代码输出结果为（）](https://www.nowcoder.com/questionTerminal/8b7e3edf00d646afb15319c31206ad31)**\n\n```java\nclass Animal{\n    public void move(){\n        System.out.println(\"动物可以移动\");\n    }\n}\nclass Dog extends Animal{\n    public void move(){\n        System.out.println(\"狗可以跑和走\");\n    }\n    public void bark(){\n        System.out.println(\"狗可以吠叫\");\n    }\n}\npublic class TestDog{\n    public static void main(String args[]){\n        Animal a = new Animal();\n        Animal b = new Dog(); \n        a.move();\n        b.move();\n        b.bark();\n    }\n}\n\n正确答案: D   你的答案: D\n\nA、 动物可以移动\n	狗可以跑和走\n	狗可以吠叫\n\nB、 动物可以移动\n    动物可以移动\n    狗可以吠叫\n\nC、 运行错误\n\nD、 编译错误\n```\n\n\n编译看左边，运行看右边。  父类型引用指向子类型对象，无法调用只在子类型里定义的方法\n\n---\n\n**[下面关于垃圾收集的说法正确的是](https://www.nowcoder.com/questionTerminal/c6586555a3774654a663c3141688aba5)**\n\n```\n正确答案: D  你的答案: D\n\nA、一旦一个对象成为垃圾，就立刻被收集掉。\nB、对象空间被收集掉之后，会执行该对象的finalize方法\nC、finalize方法和C++的析构函数是完全一回事情\nD、一个对象成为垃圾是因为不再有引用指着它，但是线程并非如此\n```\n\n> 以前我是堆，你是栈\n> 你总是能精准的找到我，给我指明出路\n> 后来有一天我明白了\n> 我变成了栈，你却隐身堆海\n> 我却找不到你了，空指针了\n>\n> 我不愿意如此，在下一轮full gc前\n> 我找到了object家的finalize\n> 又找到了你，这次我不会放手\n>\n> 在世界重启前，一边躲着full gc一边老去\n\n**1、在java中，对象的内存在哪个时刻回收，取决于垃圾回收器何时运行。** \n\n**2、**一旦垃圾回收器准备好释放对象占用的存储空间，将首先调用其finalize()方法， 并且在**下一次**垃圾回收动作发生时，才会**真正的**回收对象占用的内存（《java 编程思想》） \n\n**3、在C++中，对象的内存在哪个时刻被回收，是可以确定的，在C++中，析构函数和资源的释放息息相关，能不能正确处理析构函数，关乎能否正确回收对象内存资源。**\n\n**在java中，对象的内存在哪个时刻回收，取决于垃圾回收器何时运行**，在java中，所有的对象，包括对象中包含的其他对象，它们所占的内存的回收都依靠垃圾回收器，因此不需要一个函数如C++析构函数那样来做必要的垃圾回收工作。当然存在本地方法时需要finalize()方法来清理本地对象。在《java编程思想》中提及，finalize()方法的一个作用是用来回收“本地方法”中的本地对象 \n\n4、**“但是线程并非如此”不理解，希望大佬补充**\n\n---\n**[下面哪段程序能够正确的实现了GBK编码字节流到UTF-8编码字节流的转换：](https://www.nowcoder.com/questionTerminal/093bfa948d144ce3b0a68b938ae8b4ec)**\n\n```java\nbyte[] src,dst;\n\n正确答案: B  你的答案: B\n\nA、dst=String.fromBytes(src，\"GBK\").getBytes(\"UTF-8\")\nB、dst=new String(src，\"GBK\").getBytes(\"UTF-8\")\nC、dst=new String(\"GBK\"，src).getBytes()\nD、dst=String.encode(String.decode(src，\"GBK\"))，\"UTF-8\" )\n```\n\n> 选B，先通过GBK编码还原字符串，在该字符串正确的基础上得到“UTF-8”所对应的字节串。\n\n---\n\n**[socket编程中，以下哪个socket的操作是不属于服务端操作的（）](https://www.nowcoder.com/questionTerminal/38fb0886232b42b6a542c288d256eee1)** \n\n```\n正确答案: C  你的答案: C\n\nA、accept\nB、listen\nC、connect\nD、close\n```\n\n\n![img](https://img-blog.csdnimg.cn/img_convert/b7b9ab2339dc68d8e38e8c342941b292.png) \n\nTCP客户端： \n\n1. 建立连接套接字，设置Ip和端口监听，socket() \n2. 建立连接 connect \n3. write() 获取网络流对象 发送数据 \n4. read()获取网络流对象 接收数据 \n5. 关闭套接字   \n\n\nTCP服务器端\n\n1. 建立端口监听 socket() \n2. 绑定指定端口 bind() \n3. listen 进行端口监听 \n4. accept() 阻塞式 直到有客户端访问 \n5. read()获取客户端发送数据 \n6. write()发送返回数据 \n7. close关闭端口监听 \n\n---\n\n**[下面关于volatile的功能说法正确的是哪个](https://www.nowcoder.com/questionTerminal/81888b413fae42348429b845242c4edd)**\n\n```\n正确答案: B C  你的答案: B C\n\nA、原子性\nB、有序性\nC、可见性\nD、持久性\n```\n\n> synchronized保证三大性，原子性，有序性，可见性，volatile保证有序性，可见性，不能保证原子性\n\n\n---\n\n**[以下哪些jvm的垃圾回收方式采用的是复制算法回收](https://www.nowcoder.com/questionTerminal/795b066b67c84478aec4dc400b3d0153)**\n\n```\n正确答案: A D  你的答案: A D\n\nA、新生代串行收集器\nB、老年代串行收集器\nC、并行收集器\nD、新生代并行回收收集器\nE、老年代并行回收收集器\nF、cms收集器\n```\n\n两个最基本的java回收算法：**复制算法和标记清理算法** \n\n复制算法：两个区域A和B，初始对象在A，继续存活的对象被转移到B。此为新生代最常用的算法\n\n标记清理：一块区域，标记可达对象（可达性分析），然后回收不可达对象，会出现碎片，那么引出\n\n标记整理算法：多了碎片整理，整理出更大的内存放更大的对象\n\n两个概念：新生代和老年代\n新生代：初始对象，生命周期短的\n老年代：长时间存在的对象\n整个java的垃圾回收是新生代和老年代的协作，这种叫做分代回收。 \n\n> Serial New收集器是针对新生代的收集器，采用的是复制算法\n> Parallel New（并行）收集器，新生代采用复制算法，老年代采用标记整理\n> Parallel  Scavenge（并行）收集器，针对新生代，采用复制收集算法\n> Serial Old（串行）收集器，新生代采用复制，老年代采用标记整理\n> Parallel  Old（并行）收集器，针对老年代，标记整理\n> CMS收集器，基于标记清理\n> G1收集器：整体上是基于标记 整理 ，局部采用复制\n>\n> 综上：新生代基本采用复制算法，老年代采用标记整理算法。cms采用标记清理。\n\n---\n\n**[假如某个JAVA进程的JVM参数配置如下：`-Xms1G -Xmx2G -Xmn500M -XX:MaxPermSize=64M -XX:+UseConcMarkSweepGC -XX:SurvivorRatio=3 `请问eden区最终分配的大小是多少？](https://www.nowcoder.com/questionTerminal/d712bfe6954140958c953adcb6bf04d1)**\n\n```\n正确答案: C  你的答案: C\n\nA、64M\nB、500M\nC、300M\nD、100M\n```\n\n`Xms` 起始内存\n`Xmx` 最大内存\n`Xmn` 新生代内存\n`Xss` 栈大小。 就是创建线程后，分配给每一个线程的内存大小\n`-XX:NewRatio=n`:设置年轻代和年老代的比值。如:为3，表示年轻代与年老代比值为1：3，年轻代占整个年轻代年老代和的1/4\n`-XX:SurvivorRatio=n`:年轻代中Eden区与两个Survivor区的比值。注意Survivor区有两个。如：3，表示Eden：Survivor=3：2，一个Survivor区占整个年轻代的1/5\n`-XX:MaxPermSize=n`:设置持久代大小\n\n收集器设置\n`-XX:+UseSerialGC`:设置串行收集器\n`-XX:+UseParallelGC`:设置并行收集器\n`-XX:+UseParalledlOldGC`:设置并行年老代收集器\n`-XX:+UseConcMarkSweepGC`:设置并发收集器\n\n垃圾回收统计信息\n`-XX:+PrintGC`\n`-XX:+PrintGCDetails`\n`-XX:+PrintGCTimeStamps`\n`-Xloggc:filename`\n\n并行收集器设置\n`-XX:ParallelGCThreads=n`:设置并行收集器收集时使用的CPU数。并行收集线程数。\n`-XX:MaxGCPauseMillis=n`:设置并行收集最大暂停时间\n`-XX:GCTimeRatio=n`:设置垃圾回收时间占程序运行时间的百分比。公式为1/(1+n)\n\n并发收集器设置\n`-XX:+CMSIncrementalMode`:设置为增量模式。适用于单CPU情况。\n`-XX:ParallelGCThreads=n`:设置并发收集器年轻代收集方式为并行收集时，使用的CPU数。并行收集线程数。\n\n---\n\n**[要使某个类能被同一个包中的其他类访问，但不能被这个包以外的类访问，可以( )](https://www.nowcoder.com/questionTerminal/fe708884a2074763b6d5d1dd62a52817)**\n\n```\n正确答案: A   你的答案: A\n\nA、让该类不使用任何关键字\nB、使用private关键字\nC、使用protected关键字\nD、使用void关键字\n```\n\n> default和protected的区别是： \n> 前者只要是外部包，就不允许访问。 \n> 后者只要是子类就允许访问，即使子类位于外部包。\n>\n> 总结：default拒绝一切包外访问；protected接受包外的子类访问 \n\n![img](https://img-blog.csdnimg.cn/img_convert/6519996d6f04d348cf137fb3ce8f96e4.png)  \n\n\n**[jvm中垃圾回收分为scanvenge gc和full GC，其中full GC触发的条件可能有哪些](https://www.nowcoder.com/questionTerminal/6e9fadc9f3234551bd92d6331a14607d)**\n\n```\n正确答案: C D E  你的答案: C D E\n\nA、栈空间满\nB、年轻代空间满\nC、老年代满\nD、持久代满\nE、System.gc()\n```\n\n垃圾收集机制：新生代、老年代、持久代 ![img](https://img-blog.csdnimg.cn/img_convert/473535d0278cf5124fe05fafa020b672.png)\n\n1. 新生代：（1）所有对象创建在新生代的Eden区，当Eden区满后触发新生代的Minor  GC，将Eden区和非空闲Survivor区存活的对象复制到另外一个空闲的Survivor区中。（2）保证一个Survivor区是空的，新生代Minor  GC就是在两个Survivor区之间相互复制存活对象，直到Survivor区满为止。\n2. 老年代：当Survivor区也满了之后就通过Minor GC将对象复制到老年代。老年代也满了的话，就将触发Full  GC，针对整个堆（包括新生代、老年代、持久代）进行垃圾回收。\n3. 持久代：持久代如果满了，将触发Full GC。\n\n---\n\n**[关于java集合下列说法不正确的有哪些（）](https://www.nowcoder.com/questionTerminal/3dbb60125c2b47918b03ecb112b9c2cb)**\n\n```\n正确答案: A B D  你的答案: A B D\n\nA、HashSet 它是线程安全的，不允许存储相同的对象\nB、ConcurrentHashMap 它是线程安全的，其中存储的键对象可以重复，值对象不能重复\nC、Collection接口是List接口和Set接口的父接口，通常情况下不被直接使用\nD、ArrayList线程安全的，允许存放重复对象\n```\n\n\n**线程安全(Thread-safe)的集合对象：**  \n\n- Vector\n- HashTable\n- StringBuffer     \n\n**非线程安全的集合对象：**  \n\n- ArrayList      \n- LinkedList      \n- HashMap      \n- HashSet \n- TreeMap      \n- TreeSet \n- StringBulider\n\n---\n\n**[若有定义语句： int a=10 ; double b=3.14 ; 则表达式 \'A\'+a+b 值的类型是（）](https://www.nowcoder.com/questionTerminal/460e40f8824244efaf73ae088724f5f3)**\n\n```\n正确答案: C  你的答案: C\n\nA、char\nB、int\nC、double\nD、float\n```\n\n> char < short < int < float < double 不同类型运算结果类型向右边靠齐。\n\n---\n\n**[JVM内存不包含如下哪个部分( )](https://www.nowcoder.com/questionTerminal/04c442aaf1e14bf9819075cc1f29d899)** \n\n```\n正确答案: D  你的答案: D\n\nA、Stacks\nB、PC寄存器\nC、Heap\nD、Heap Frame\n```\nJVM内存五大区域\n\n![img](https://img-blog.csdnimg.cn/img_convert/068228de4fb1e0c052335193fabd08e6.png)\n\n---\n\n**[关于下列程序段的输出结果，说法正确的是：（  ）](https://www.nowcoder.com/questionTerminal/9316826838a644b3a66ff1e9e610eb34)**      \n\n```java\npublic class MyClass{\n    static int i;\n    public static void main(String   argv[]){\n        System.out.println(i);\n    }\n}\n\n正确答案: D  你的答案: D\n\nA、有错误，变量i没有初始化。\nB、null\nC、1\nD、0\n\n```\n\n> 类变量在不设置初始值时，会进行默认值赋值，而局部方法中声明的变量则必须进行初始化，他不会进行默认值赋值。\n\n---\n\n**[以下程序执行的结果是：](https://www.nowcoder.com/questionTerminal/27a89bce14c242d1a4161fbeca2b6b7e)** \n\n```java\nclass X{\n	Y y=new Y();\n	public X(){\n		System.out.print(\"X\");\n	}\n}\nclass Y{\n	public Y(){\n		System.out.print(\"Y\");\n	}\n}\npublic class Z extends X{\n	Y y=new Y();\n	public Z(){\n		System.out.print(\"Z\");\n	}\n	public static void main(String[] args) {\n		new Z();\n	}\n}\n\n正确答案: C   你的答案: C\n\nA、ZYXX\nB、ZYXY\nC、YXYZ\nD、XYZX\n```\n\n初始化过程： \n\n1. 初始化父类中的静态成员变量和静态代码块  ； \n2. 初始化子类中的静态成员变量和静态代码块  ； \n3. 初始化父类的普通成员变量和代码块，再执行父类的构造方法；\n4. 初始化子类的普通成员变量和代码块，再执行子类的构造方法； \n\n执行过程：\n\n（1）初始化父类的普通成员变量和代码块，执行`Y y=new Y();`输出Y \n（2）再执行父类的构造方法；输出X\n（3）初始化子类的普通成员变量和代码块，执行`Y y=new Y();`输出Y   \n（4）再执行子类的构造方法；输出Z\n（5）所以输出YXYZ\n\n\n\n## 笔记\n\n**[UNIX操作系统是著名的（）](https://www.nowcoder.com/questionTerminal/a1b1da8583b9490fa91e319bd090ca2e)**\n\n```\n正确答案: B  你的答案: B\n\nA、多道批处理系统\nB、分时系统\nC、实时系统\nD、分布式系统\n```\n\n\n**操作系统分类**\n\n[批处理操作系统](http://baike.baidu.com/item/批处理操作系统) （Batch Processing Operating System）它的特点是：多道和成批处理。\n\n[分时操作系统](http://baike.baidu.com/item/分时操作系统)(Time Sharing Operating System，简称TSOS)  分时系统具有多路性、交互性、“独占”性和及时性的特征。多路性指，伺时有多个用户使用一台计算机，宏观上看是多个人同时使用一个CPU，微观上是多个人在不同时刻轮流使用CPU。交互性是指，用户根据系统响应结果进一步提出新请求(用户直接干预每一步)。“独占”性是指，用户感觉不到计算机为其他人服务，就像整个系统为他所独占。及时性指，系统对用户提出的请求及时响应。\n\n[实时操作系统](http://baike.baidu.com/item/实时操作系统)(Real Time Operating System，简称RTOS)  实时操作系统要追求的目标是：对外部请求在严格时间范围内做出反应，有高可靠性和完整性。其主要特点是资源的分配和调度首先要考虑实时性然后才是效率。此外，实时操作系统应有较强的容错能力。\n\n[网络操作系统](http://baike.baidu.com/item/网络操作系统)（Network Operating System，简称NOS）通常运行在服务器上的操作系统，是基于计算机网络的，其目标是相互通信及资源共享。\n\n[分布式操作系统](http://baike.baidu.com/item/分布式操作系统)  (Distributed Software Systems)是为分布计算系统配置的操作系统。大量的计算机通过网络被连结在一起，可以获得极高的运算能力及广泛的数据共享。\n\n分布式操作系统是网络操作系统的更高形式，它保持了网络操作系统的全部功能，而且还具有透明性、可靠性和高性能等。网络操作系统和分布式操作系统虽然都用于管理分布在不同地理位置的计算机，但最大的差别是：网络操作系统知道确切的网址，而分布式系统则不知道计算机的确切地址；分布式操作系统负责整个的资源分配，能很好地隐藏系统内部的实现细节，如对象的物理位置等。这些都是对用户透明的。\n\n---\n\n**[计算机内的传输是 （）传输，而通信线路上的传输是（）传输。](https://www.nowcoder.com/questionTerminal/00560b154d994da0846e4c8e13b2a626)**\n\n```\n正确答案: A  你的答案: A\n\nA、并行，串行\nB、串行，并行\nC、并行，并行\nD、串行，串行\n```\n\n\n并行数据传输: 是在传输中有多个数据位同时在设备之间进行的传输.一个编了码的字符通常是由若干位二进制数表示,如用ASCII码编码的符号是由8位二进制数表示的,则并行传输ASCII编码符号就需要8个传输信道,使表示一个符号的所有数据位能同时沿着各自的信道并排的传输.。\n\n串行数据传输:是在传输中只有1个数据位在设备之间进行的传输.对任何一个由若干位二进制表示的字符,串行传输都是用一个传输信道,按位有序的对字符进行传输。\n\n区别: 串行传输的速度比并行传输的速度要慢得多,但费用低.并行传输适用距离短,而串行传输适用远距离传输\n\n---\n\n**[下面哪项技术可以用在WEB开发中实现会话跟踪实现？](https://www.nowcoder.com/questionTerminal/8d86bb29952642169e816d519f8417f3)**\n\n```\n正确答案: A B C D  你的答案: A B C D\n\nA、session\nB、Cookie\nC、地址重写\nD、隐藏域\n```\n\n会话跟踪是一种灵活、轻便的机制，它使Web上的状态编程变为可能。\n\nHTTP是一种无状态协议，每当用户发出请求时，服务器就会做出响应，客户端与服务器之间的联系是离散的、非连续的。当用户在同一网站的多个页面之间转换时，根本无法确定是否是同一个客户，会话跟踪技术就可以解决这个问题。当一个客户在多个页面间切换时，服务器会保存该用户的信息。\n\n有四种方法可以实现会话跟踪技术：URL重写、隐藏表单域、Cookie、Session。\n\n1. 隐藏表单域：<input type=\"hidden\">，非常适合步需要大量数据存储的会话应用。\n2. URL重写:URL可以在后面附加参数，和服务器的请求一起发送，这些参数为名字/值对。\n3. Cookie:一个Cookie是一个小的，已命名数据元素。服务器使用 SET-Cookie 头标将它作为HTTP响应的一部分传送到客户端，客户端被请求保存Cookie值，在对同一服务器的后续请求使用一个Cookie头标将之返回到服务器。与其它技术比较，Cookie的一个优点是在浏览器会话结束后，甚至在客户端计算机重启后它仍可以保留其值\n4. Session：使用  setAttribute(String str,Object obj)方法将对象捆绑到一个会话\n\n---\n\n**[Windows  操作系统中，文件组织采用（）目录结构。](https://www.nowcoder.com/questionTerminal/dc12220c61044df6b4d3105020e220ab)**\n\n```\n正确答案: C  你的答案: C\n\nA、分区\nB、关系型\nC、树型\nD、网状\n```\n> windows操作系统的目录结构是树形结构。就像一棵树，它的树干就是根目录，然后第一个分枝之后是第一层目录\n\n---\n\n**[目录在linux文件系统中是以怎样的形式存在的？](https://www.nowcoder.com/questionTerminal/39c85d760469456aa105ea30d591c109)**\n\n```\n正确答案: B  你的答案: B\n\nA、文件夹\nB、文件\nC、inode\nD、软链接\n```\n\n> Linux系统下，一切都是文件，硬件设备也是文件\n\n---\n\n**[下列进程通信机制中， UNIX 系统中没有采用的机制是（ ）](https://www.nowcoder.com/questionTerminal/5209ef4738724f659ea658fd44b3c83e)**\n\n```\n正确答案: B  你的答案: B\n\nA、信号量集\nB、管程机制\nC、软中断信号\nD、套接字\n```\n\nLinux进程间通信：管道、信号、消息队列、共享内存、信号量、套接字(socket) \n\nLinux线程间通信：互斥量（mutex），信号量，条件变量 \n\nWindows进程间通信：管道、消息队列、共享内存、信号量（semaphore）、套接字(socket) \n\nWindows线程间通信：互斥量（mutex），信号量（semaphore）、临界区（critical section）、事件（event） \n\n---\n> IPv4地址32位\n> MAC地址48位\n> IPv6地址128位 \n\n**网络状态码**\n\n| 状态码 | 英文                            | 解释                                                         |\n| :----- | :------------------------------ | ------------------------------------------------------------ |\n| 100    | Continue                        | 继续。客户端应继续其请求                                     |\n| 101    | Switching Protocols             | 切换协议。服务器根据客户端的请求切换协议。只能切换到更高级的协议，例如，切换到HTTP的新版本协议 |\n| 200    | OK                              | 请求成功。一般用于GET与POST请求                              |\n| 201    | Created                         | 已创建。成功请求并创建了新的资源                             |\n| 202    | Accepted                        | 已接受。已经接受请求，但未处理完成                           |\n| 203    | Non-Authoritative Information   | 非授权信息。请求成功。但返回的meta信息不在原始的服务器，而是一个副本 |\n| 204    | No Content                      | 无内容。服务器成功处理，但未返回内容。在未更新网页的情况下，可确保浏览器继续显示当前文档 |\n| 205    | Reset Content                   | 重置内容。服务器处理成功，用户终端（例如：浏览器）应重置文档视图。可通过此返回码清除浏览器的表单域 |\n| 206    | Partial Content                 | 部分内容。服务器成功处理了部分GET请求                        |\n| 300    | Multiple Choices                | 多种选择。请求的资源可包括多个位置，相应可返回一个资源特征与地址的列表用于用户终端（例如：浏览器）选择 |\n| 301    | Moved Permanently               | 永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替 |\n| 302    | Found                           | 临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI |\n| 303    | See Other                       | 查看其它地址。与301类似。使用GET和POST请求查看               |\n| 304    | Not Modified                    | 未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源 |\n| 305    | Use Proxy                       | 使用`***`。所请求的资源必须通过`***`访问                     |\n| 306    | Unused                          | 已经被废弃的HTTP状态码                                       |\n| 307    | Temporary Redirect              | 临时重定向。与302类似。使用GET请求重定向                     |\n| 400    | Bad Request                     | 客户端请求的语法错误，服务器无法理解                         |\n| 401    | Unauthorized                    | 请求要求用户的身份认证                                       |\n| 402    | Payment Required                | 保留，将来使用                                               |\n| 403    | Forbidden                       | 服务器理解请求客户端的请求，但是拒绝执行此请求               |\n| 404    | Not Found                       | 服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置\"您所请求的资源无法找到\"的个性页面 |\n| 405    | Method Not Allowed              | 客户端请求中的方法被禁止                                     |\n| 406    | Not Acceptable                  | 服务器无法根据客户端请求的内容特性完成请求                   |\n| 407    | Proxy Authentication Required   | 请求要求`***`的身份认证，与401类似，但请求者应当使用`***`进行授权 |\n| 408    | Request Time-out                | 服务器等待客户端发送的请求时间过长，超时                     |\n| 409    | Conflict                        | 服务器完成客户端的PUT请求是可能返回此代码，服务器处理请求时发生了冲突 |\n| 410    | Gone                            | 客户端请求的资源已经不存在。410不同于404，如果资源以前有现在被永久删除了可使用410代码，网站设计人员可通过301代码指定资源的新位置 |\n| 411    | Length Required                 | 服务器无法处理客户端发送的不带Content-Length的请求信息       |\n| 412    | Precondition Failed             | 客户端请求信息的先决条件错误                                 |\n| 413    | Request Entity Too Large        | 由于请求的实体过大，服务器无法处理，因此拒绝请求。为防止客户端的连续请求，服务器可能会关闭连接。如果只是服务器暂时无法处理，则会包含一个Retry-After的响应信息 |\n| 414    | Request-URI Too Large           | 请求的URI过长（URI通常为网址），服务器无法处理               |\n| 415    | Unsupported Media Type          | 服务器无法处理请求附带的媒体格式                             |\n| 416    | Requested range not satisfiable | 客户端请求的范围无效                                         |\n| 417    | Expectation Failed              | 服务器无法满足Expect的请求头信息                             |\n| 500    | Internal Server Error           | 服务器内部错误，无法完成请求                                 |\n| 501    | Not Implemented                 | 服务器不支持请求的功能，无法完成请求                         |\n| 502    | Bad Gateway                     | 作为网关或者***工作的服务器尝试执行请求时，从远程服务器接收到了一个无效的响应 |\n| 503    | Service Unavailable             | 由于超载或系统维护，服务器暂时的无法处理客户端的请求。延时的长度可包含在服务器的Retry-After头信息中 |\n| 504    | Gateway Time-out                | 充当网关或***的服务器，未及时从远端服务器获取请求            |\n| 505    | HTTP Version not supported      | 服务器不支持请求的HTTP协议的版本，无法完成处理               |\n\n---\n\n**设计模式分类**\n\n**一、创建型模式**\n\n工厂模式（Factory Pattern）\n抽象工厂模式（Abstract Factory Pattern）\n单例模式（Singleton Pattern）\n建造者模式（Builder Pattern）\n原型模式（Prototype Pattern）\n\n**二、结构型模式**\n\n适配器模式（Adapter Pattern）\n桥接模式（Bridge Pattern）\n过滤器模式（Filter、Criteria Pattern）\n组合模式（Composite Pattern）\n装饰器模式（Decorator Pattern）\n外观模式（Facade Pattern）\n享元模式（Flyweight Pattern）\n代理模式（Proxy Pattern）\n\n**三、行为型模式**\n\n责任链模式（Chain of Responsibility Pattern）\n命令模式（Command Pattern）\n解释器模式（Interpreter Pattern）\n迭代器模式（Iterator Pattern）\n中介者模式（Mediator Pattern）\n备忘录模式（Memento Pattern）\n观察者模式（Observer Pattern）\n状态模式（State Pattern）\n空对象模式（Null Object Pattern）\n策略模式（Strategy Pattern）\n模板模式（Template Pattern）\n访问者模式（Visitor Pattern）\n\n---\n\n> **常用 ASCII 码值**\n>\n> 空格为 32\n> 数字0为 48\n> “A”为 65\n> “a”值为 97\n\n---\n\n**JVM常用命令**\n\n1. jps：查看本机java进程信息。\n2. jstack：打印线程的栈信息，制作线程dump文件。\n3. jmap：打印内存映射，制作堆dump文件\n4. jstat：性能监控工具\n5. jhat：内存分析工具\n6. jconsole：简易的可视化控制台\n7. jvisualvm：功能强大的控制台\n\n---\n\n**数据库系统的三级模式结构**\n\n数据库系统的三级模式结构是指数据库系统是由**外模式**、**模式**和**内模式**三级构成.\n 为了能够在系统内部实现这 3 个抽象层次的联系和转换，数据库管理系统在这三级模式之间提供了两层映像：\n **外模式/模式映像**（映像定义通常包含在各自外模式的描述中，保证了数据与程序的逻辑独立性，简称**数据的逻辑独立性**，应用程序是依据外模式编写的）\n **模式/内模式映像**（包含在模式描述中，此映像是唯一的，它定义了数据全局逻辑结构与存储结构之间的对应关系，它保证了数据与程序的物理独立性，所以称为**数据的物理独立性**）\n\n---\n\n**1NF,2NF,3NF**\n\n1NF : 属性是原子性的，即不可拆分的；例如姓名这个属性是一般不可拆分的；而社会保险号如果是由出生年月日与姓名缩写构成的话，就是可拆分的：包含可拆分的含义：出生年月日，姓名； 是否可拆分取决于对含义的解释；\n\n2NF：解决了非主键属性对主键属性的部分依赖；如表（A, B, C, D），其中ABCD代表属性，假设（A,  B）是主键，若C只依赖于B，则这个表是不符合2NF的，可拆分为（A, B, D）与  （B,  C）两张表；很明显，如果主键只有一个属性，那么肯定是2NF\n\n3NF：解决了非主键属性对主键属性的传递依赖；如表（A,B,C,D），如果主键是A,  而B依赖于A，C依赖于B，则这个表有传递依赖，是不符合3NF的；\n\n范式的目的是为了**减少/消除冗余**\n\n---\n\n**共享锁/排他锁**\n\n共享锁【S锁】，又称读锁，若事务T对数据对象A加上S锁，则事务T可以读A但不能修改A，其他事务只能再对A加S锁，而不能加X锁，直到T释放A上的S锁。这保证了其他事务可以读A，但在T释放A上的S锁之前不能对A做任何修改。\n\n排他锁【X锁】，又称写锁。若事务T对数据对象A加上X锁，事务T可以读A也可以修改A，其他事务不能再对A加任何锁，直到T释放A上的锁。这保证了其他事务在T释放A上的锁之前不能再读取和修改A。\n\n---\n\n**事务的特性**\n\n原子性（Atomicity）：是事务执行的最小单位。不允许分割。事务的原子性确保动作要么全部成功，要么全部失败\n一致性（Consistency）：执行事务的前后，数据保持不变\n隔离性（Isolation）：并发访问事务时，一个用户的事务数据不能被其他事务所干扰。各并发事务之间的数据库是独立的\n持久性（Durability）：一个事物被提交后，他对数据库的数据改变时持久的。即使数据库发生故障，也不应该对数据有影响', '24', '日常随笔', 'java,操作系统,数据结构,计算机网络', '1', '168', '0', '0', '2021-02-22 19:05:18', '2021-02-22 19:05:18');
INSERT INTO `tb_blog` VALUES ('13', '测试文章', '这是测试文章的摘要', '哈哈哈哈哈哈哈哈哈\n', '24', '日常随笔', '123456', '1', '0', '0', '1', '2021-03-01 18:28:02', '2021-03-01 18:28:02');
INSERT INTO `tb_blog` VALUES ('14', 'java123456', 'asdadad', 'adsadasdsada', '24', '日常随笔', '4566854787', '1', '0', '0', '1', '2021-03-02 18:01:06', '2021-03-02 18:01:06');
INSERT INTO `tb_blog` VALUES ('15', '一篇测试文章', '一段摘要啦啦啦啦啦啦啦', 'hhhhhhhhajksdhajkdhj skl', '24', '日常随笔', 'hdgsajhgdjha', '1', '0', '0', '1', '2021-03-02 18:04:16', '2021-03-02 18:04:16');

-- ----------------------------
-- Table structure for tb_blog_category
-- ----------------------------
DROP TABLE IF EXISTS `tb_blog_category`;
CREATE TABLE `tb_blog_category` (
  `category_id` int(11) NOT NULL AUTO_INCREMENT COMMENT '分类表主键',
  `category_name` varchar(50) NOT NULL COMMENT '分类的名称',
  `category_icon` varchar(50) NOT NULL COMMENT '分类的图标',
  `category_rank` int(11) NOT NULL DEFAULT '1' COMMENT '分类的排序值 被使用的越多数值越大',
  `is_deleted` tinyint(4) NOT NULL DEFAULT '0' COMMENT '是否删除 0=否 1=是',
  `create_time` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
  PRIMARY KEY (`category_id`)
) ENGINE=InnoDB AUTO_INCREMENT=26 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of tb_blog_category
-- ----------------------------
INSERT INTO `tb_blog_category` VALUES ('24', '日常随笔', '/admin/dist/img/category/06.png', '42', '0', '2018-11-12 10:43:21');
INSERT INTO `tb_blog_category` VALUES ('25', '开发', '/admin/dist/img/category/16.png', '8', '0', '2021-02-24 19:30:32');

-- ----------------------------
-- Table structure for tb_blog_comment
-- ----------------------------
DROP TABLE IF EXISTS `tb_blog_comment`;
CREATE TABLE `tb_blog_comment` (
  `comment_id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT '主键id',
  `blog_id` bigint(20) NOT NULL DEFAULT '0' COMMENT '关联的blog主键',
  `commentator` varchar(50) NOT NULL DEFAULT '' COMMENT '评论者名称',
  `email` varchar(100) NOT NULL DEFAULT '' COMMENT '评论人的邮箱',
  `website_url` varchar(50) NOT NULL DEFAULT '' COMMENT '网址',
  `comment_body` varchar(200) NOT NULL DEFAULT '' COMMENT '评论内容',
  `comment_create_time` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '评论提交时间',
  `commentator_ip` varchar(20) NOT NULL DEFAULT '' COMMENT '评论时的ip地址',
  `reply_body` varchar(200) NOT NULL DEFAULT '' COMMENT '回复内容',
  `reply_create_time` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '回复时间',
  `comment_status` tinyint(4) NOT NULL DEFAULT '0' COMMENT '是否审核通过 0-未审核 1-审核通过',
  `is_deleted` tinyint(4) DEFAULT '0' COMMENT '是否删除 0-未删除 1-已删除',
  PRIMARY KEY (`comment_id`)
) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of tb_blog_comment
-- ----------------------------
INSERT INTO `tb_blog_comment` VALUES ('1', '6', '哈哈哈', '3496655347@qq.com', '', '点赞，好文', '2021-02-25 18:37:53', '', '', '2021-02-25 18:37:53', '1', '1');
INSERT INTO `tb_blog_comment` VALUES ('2', '11', '张三', '123456@qq.com', '', '这是一条认真的评论 哈哈', '2021-03-01 18:36:16', '', '', '2021-03-01 18:36:16', '1', '0');

-- ----------------------------
-- Table structure for tb_blog_tag
-- ----------------------------
DROP TABLE IF EXISTS `tb_blog_tag`;
CREATE TABLE `tb_blog_tag` (
  `tag_id` int(11) NOT NULL AUTO_INCREMENT COMMENT '标签表主键id',
  `tag_name` varchar(100) NOT NULL COMMENT '标签名称',
  `is_deleted` tinyint(4) NOT NULL DEFAULT '0' COMMENT '是否删除 0=否 1=是',
  `create_time` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
  PRIMARY KEY (`tag_id`)
) ENGINE=InnoDB AUTO_INCREMENT=21 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of tb_blog_tag
-- ----------------------------
INSERT INTO `tb_blog_tag` VALUES ('1', 'java', '0', '2021-02-24 10:24:58');
INSERT INTO `tb_blog_tag` VALUES ('2', '数据结构', '0', '2021-02-24 10:24:58');
INSERT INTO `tb_blog_tag` VALUES ('3', '计算机网络', '0', '2021-02-24 10:24:58');
INSERT INTO `tb_blog_tag` VALUES ('4', '操作系统', '0', '2021-02-24 10:24:58');
INSERT INTO `tb_blog_tag` VALUES ('5', '博客', '0', '2021-02-24 19:37:11');
INSERT INTO `tb_blog_tag` VALUES ('6', 'hugo', '0', '2021-02-24 19:37:11');
INSERT INTO `tb_blog_tag` VALUES ('7', 'idea', '0', '2021-02-24 19:39:06');
INSERT INTO `tb_blog_tag` VALUES ('8', 'javaScript', '0', '2021-02-24 19:41:27');
INSERT INTO `tb_blog_tag` VALUES ('10', 'ssh', '0', '2021-02-24 19:49:45');
INSERT INTO `tb_blog_tag` VALUES ('11', 'visio', '0', '2021-02-24 19:51:31');
INSERT INTO `tb_blog_tag` VALUES ('12', 'mysql', '0', '2021-02-24 19:54:21');
INSERT INTO `tb_blog_tag` VALUES ('13', 'python', '0', '2021-02-24 19:54:21');
INSERT INTO `tb_blog_tag` VALUES ('14', 'selenium', '0', '2021-02-24 19:54:21');
INSERT INTO `tb_blog_tag` VALUES ('15', 'markdown', '0', '2021-02-24 19:56:37');
INSERT INTO `tb_blog_tag` VALUES ('16', 'github', '0', '2021-02-24 19:57:29');
INSERT INTO `tb_blog_tag` VALUES ('17', '123456', '0', '2021-03-01 18:28:02');
INSERT INTO `tb_blog_tag` VALUES ('18', '555', '1', '2021-03-02 16:09:17');
INSERT INTO `tb_blog_tag` VALUES ('19', '4566854787', '0', '2021-03-02 18:01:06');
INSERT INTO `tb_blog_tag` VALUES ('20', 'hdgsajhgdjha', '0', '2021-03-02 18:04:16');

-- ----------------------------
-- Table structure for tb_blog_tag_relation
-- ----------------------------
DROP TABLE IF EXISTS `tb_blog_tag_relation`;
CREATE TABLE `tb_blog_tag_relation` (
  `relation_id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT '关系表id',
  `blog_id` bigint(20) NOT NULL COMMENT '博客id',
  `tag_id` int(11) NOT NULL COMMENT '标签id',
  `create_time` datetime DEFAULT CURRENT_TIMESTAMP COMMENT '添加时间',
  PRIMARY KEY (`relation_id`)
) ENGINE=InnoDB AUTO_INCREMENT=311 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of tb_blog_tag_relation
-- ----------------------------
INSERT INTO `tb_blog_tag_relation` VALUES ('281', '1', '1', '2021-02-24 10:24:58');
INSERT INTO `tb_blog_tag_relation` VALUES ('282', '2', '1', '2021-02-24 10:24:58');
INSERT INTO `tb_blog_tag_relation` VALUES ('283', '2', '15', '2021-02-24 10:24:58');
INSERT INTO `tb_blog_tag_relation` VALUES ('284', '3', '1', '2021-02-24 10:24:58');
INSERT INTO `tb_blog_tag_relation` VALUES ('285', '3', '12', '2021-02-24 19:37:11');
INSERT INTO `tb_blog_tag_relation` VALUES ('286', '7', '6', '2021-02-24 19:37:11');
INSERT INTO `tb_blog_tag_relation` VALUES ('287', '4', '7', '2021-02-24 19:39:06');
INSERT INTO `tb_blog_tag_relation` VALUES ('288', '5', '11', '2021-02-24 19:41:27');
INSERT INTO `tb_blog_tag_relation` VALUES ('289', '6', '12', '2021-02-24 19:42:44');
INSERT INTO `tb_blog_tag_relation` VALUES ('290', '6', '13', '2021-02-24 19:43:55');
INSERT INTO `tb_blog_tag_relation` VALUES ('291', '6', '14', '2021-02-24 19:46:46');
INSERT INTO `tb_blog_tag_relation` VALUES ('292', '7', '1', '2021-02-24 19:49:45');
INSERT INTO `tb_blog_tag_relation` VALUES ('293', '8', '10', '2021-02-24 19:50:38');
INSERT INTO `tb_blog_tag_relation` VALUES ('294', '9', '13', '2021-02-24 19:51:31');
INSERT INTO `tb_blog_tag_relation` VALUES ('295', '10', '16', '2021-02-24 19:52:31');
INSERT INTO `tb_blog_tag_relation` VALUES ('296', '11', '1', '2021-02-24 19:54:21');
INSERT INTO `tb_blog_tag_relation` VALUES ('297', '11', '13', '2021-02-24 19:54:21');
INSERT INTO `tb_blog_tag_relation` VALUES ('302', '13', '17', '2021-03-01 18:28:02');
INSERT INTO `tb_blog_tag_relation` VALUES ('303', '12', '1', '2021-03-01 18:44:21');
INSERT INTO `tb_blog_tag_relation` VALUES ('304', '12', '4', '2021-03-01 18:44:21');
INSERT INTO `tb_blog_tag_relation` VALUES ('305', '12', '2', '2021-03-01 18:44:21');
INSERT INTO `tb_blog_tag_relation` VALUES ('306', '12', '3', '2021-03-01 18:44:21');
INSERT INTO `tb_blog_tag_relation` VALUES ('307', '14', '19', '2021-03-02 18:01:06');
INSERT INTO `tb_blog_tag_relation` VALUES ('310', '15', '20', '2021-03-02 18:12:46');

-- ----------------------------
-- Table structure for tb_config
-- ----------------------------
DROP TABLE IF EXISTS `tb_config`;
CREATE TABLE `tb_config` (
  `config_name` varchar(100) NOT NULL DEFAULT '' COMMENT '配置项的名称',
  `config_value` varchar(200) NOT NULL DEFAULT '' COMMENT '配置项的值',
  `create_time` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
  `update_time` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '修改时间',
  PRIMARY KEY (`config_name`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of tb_config
-- ----------------------------
INSERT INTO `tb_config` VALUES ('footerAbout', '个人博客', '2018-11-11 20:33:23', '2023-02-26 11:09:20');
INSERT INTO `tb_config` VALUES ('footerCopyRight', '2023 mashuan', '2018-11-11 20:33:31', '2023-02-26 11:09:20');
INSERT INTO `tb_config` VALUES ('footerICP', '皖IPC备20008731号', '2018-11-11 20:33:27', '2023-02-26 11:09:20');
INSERT INTO `tb_config` VALUES ('footerPoweredBy', 'https://github.com/eternidad33', '2018-11-11 20:33:36', '2021-02-26 02:36:45');
INSERT INTO `tb_config` VALUES ('footerPoweredByURL', 'https://github.com/eternidad33', '2018-11-11 20:33:39', '2021-02-26 02:36:45');
INSERT INTO `tb_config` VALUES ('websiteDescription', 'MyBlog是SpringBoot2+Thymeleaf+Mybatis建造的个人博客网站', '2018-11-11 20:33:04', '2021-02-26 02:36:11');
INSERT INTO `tb_config` VALUES ('websiteIcon', '/admin/dist/img/favicon.png', '2018-11-11 20:33:11', '2021-02-26 02:36:11');
INSERT INTO `tb_config` VALUES ('websiteLogo', '/admin/dist/img/logo2.png', '2018-11-11 20:33:08', '2021-02-26 02:36:11');
INSERT INTO `tb_config` VALUES ('websiteName', 'MyBlog', '2018-11-11 20:33:01', '2021-02-26 02:36:11');
INSERT INTO `tb_config` VALUES ('yourAvatar', '/admin/dist/img/f.jpg', '2018-11-11 20:33:14', '2023-02-26 11:12:10');
INSERT INTO `tb_config` VALUES ('yourEmail', '859244556@qq.com', '2018-11-11 20:33:17', '2023-02-26 11:12:10');
INSERT INTO `tb_config` VALUES ('yourName', '马栓', '2018-11-11 20:33:20', '2023-02-26 11:12:10');
